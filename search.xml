<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>树型动态规划问题-打家劫舍</title>
    <url>/2019/12/20/%E6%A0%91%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>两个线程交替打印</title>
    <url>/2019/12/20/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>之前面试被问到过两个线程交替打印，实现ABABABAB这样的效果，今天无意间看到一个线程1实现1-10循环打印，打印5时通知另一个线程的题目，因此来写一下，思路基本是相同的，所以只写了第二个题的代码。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>使用synchronized进行锁操作，线程1循环打印1-10，打印5时将<code>needNotice</code>置为true表示要通知线程2，然后线程1执行<code>wait()</code>释放锁进行等待，线程2得到锁，输出信息，释放锁等待下一次被通知，线程1得到锁继续循环打印。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Printer printer =  <span class="keyword">new</span> Printer();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                printer.print();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    printer.receive();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> needNotice = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(needNotice)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + num);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">5</span>) needNotice = <span class="keyword">true</span>;</span><br><span class="line">        num = num % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!needNotice)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"接到了通知"</span>);</span><br><span class="line">        needNotice = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h1><blockquote>
<p>Thread-0print1<br>Thread-0print2<br>Thread-0print3<br>Thread-0print4<br>Thread-0print5<br>Thread-1接到了通知<br>Thread-0print6<br>Thread-0print7<br>Thread-0print8<br>Thread-0print9<br>Thread-0print10<br>Thread-0print1<br>Thread-0print2<br>Thread-0print3<br>Thread-0print4<br>Thread-0print5<br>Thread-1接到了通知<br>Thread-0print6<br>Thread-0print7<br>Thread-0print8<br>Thread-0print9<br>Thread-0print10</p>
</blockquote>
<p>截取了一部分输出，程序没有设置停止操作，会一直循环，可以设置计数器控制打印次数。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表</title>
    <url>/2019/12/20/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>题目描述：</strong></p>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<p>环形链表最简单的是判断链表中是否有环，通常使用快慢指针来进行操作，那么如何确定环的入口节点在哪里呢，起初我想到的方法就是断链，通过不断的断开一个个节点，直到遍历到一个节点的next为null，它即是环入口节点，但题目要求不能修改链表，修改链表大多数时候也不符合实际要求，此时需要使用Floyd算法，用快慢指针来完成。</p>
<p>如下图，起点A，入口点C，快慢指针相遇位置B。</p>
<p>假设黑色段为x，蓝色段为y，橙色段为z，顺时针环。</p>
<p>相遇时，fast走过的长度为<br>$$<br>x + n * (y + z) + y<br>$$<br>这里n &gt;= 1，因为fast不走完一圈不可能追上slow。</p>
<p>slow走过的长度为<br>$$<br>x + m * (y + z) + y<br>$$<br>这里m为0，因为slow至多走完一圈就会被fast追上，而若走完一圈则z = 0，即slow走过的长度为x + y。</p>
<p>已知<br>$$<br>fastLength = 2 * slowLength<br>$$<br>可得<br>$$<br>x = n(y + z) - y</p>
<p>   = (n - 1) * (y + x) + z<br>$$<br>则当一个指针从A走到C经过距离x时，另一个点会从B走(n - 1) * (y + x) + z距离，也会到达C点，而C点即是环入口点。</p>
<p><img src="https://user-images.githubusercontent.com/45253106/71247703-3f08fc80-2354-11ea-8bc0-44ba6e45b78c.png" alt="image"></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode slow = head.next;</span><br><span class="line">    ListNode fast = head.next.next;</span><br><span class="line">    <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head != slow)&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议知识整理</title>
    <url>/2019/12/19/http%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>树的层次遍历</title>
    <url>/2019/12/19/%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="Leetcode637-二叉树的层平均值"><a href="#Leetcode637-二叉树的层平均值" class="headerlink" title="Leetcode637.二叉树的层平均值"></a>Leetcode637.二叉树的层平均值</h1><p><strong>题目描述：</strong></p>
<p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">输出: [3, 14.5, 11]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>思路：**</p>
<p>典型的BFS，用队列保存层节点。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Double&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    que.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = que.size();</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            TreeNode node = que.poll();</span><br><span class="line">            sum += node.val;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) que.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) que.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        ret.add(sum / size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode513-树左下角的值"><a href="#Leetcode513-树左下角的值" class="headerlink" title="Leetcode513.树左下角的值"></a>Leetcode513.树左下角的值</h1><p><strong>题目描述：</strong></p>
<p>给定一个二叉树，在树的最后一行找到最左边的值。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">        1</span><br><span class="line">       / \</span><br><span class="line">      2   3</span><br><span class="line">     /   / \</span><br><span class="line">    4   5   6</span><br><span class="line">       /</span><br><span class="line">      7</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<p>BFS层次遍历，保留每层第一个节点的val</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    que.offer(root);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = que.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            TreeNode node = que.poll();</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) ret = node.val;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) que.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) que.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做法是和上面的题类似，但上面的题需要每层的每个节点，但这个题只需要最左节点，假设需要的是最右节点的话，我们只需要遍历至结束即可，不需要size也不需要for循环，但要求的是左节点，那么我们可以通过改变遍历顺序完成，毕竟左和右的地位相同。</p>
<p><strong>改进</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    que.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        root = que.poll();</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) que.offer(root.right);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) que.offer(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>树的递归问题</title>
    <url>/2019/12/14/%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>因为树的性质，许多问题可以用递归求解，本文总结一下树常见的问题的递归方法</p>
</blockquote>
<a id="more"></a>

<h1 id="Leetcode104-树的深度"><a href="#Leetcode104-树的深度" class="headerlink" title="Leetcode104.树的深度"></a>Leetcode104.树的深度</h1><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">Leetcode104.树的深度</a></p>
<blockquote>
<p>树的深度 = 左右子树深度较大值 + 1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode110-平衡二叉树"><a href="#Leetcode110-平衡二叉树" class="headerlink" title="Leetcode110.平衡二叉树"></a>Leetcode110.平衡二叉树</h1><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">Leetcode110.平衡二叉树</a></p>
<blockquote>
<p>平衡二叉树 = 左右子树为平衡二叉树 + 左右子树高度差 &lt;= 1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> depth(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">    <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">    <span class="keyword">if</span>(right ==  -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(right - left) &gt; <span class="number">1</span> ? -<span class="number">1</span> : Math.max(left, right) + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode543-二叉树的直径"><a href="#Leetcode543-二叉树的直径" class="headerlink" title="Leetcode543.二叉树的直径"></a>Leetcode543.二叉树的直径</h1><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">Leetcode543.二叉树的直径</a></p>
<blockquote>
<p>二叉树直径 = 二叉树任意两个结点之间路径的最大值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">    max = Math.max(max, left + right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode226-翻转二叉树"><a href="#Leetcode226-翻转二叉树" class="headerlink" title="Leetcode226.翻转二叉树"></a>Leetcode226.翻转二叉树</h1><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">Leetcode226.翻转二叉树</a></p>
<blockquote>
<p>翻转二叉树 = 翻转左子树 + 翻转右子树 + 交换左右子树位置</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode left = invertTree(root.left);</span><br><span class="line">    TreeNode right = invertTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode617-合并二叉树"><a href="#Leetcode617-合并二叉树" class="headerlink" title="Leetcode617.合并二叉树"></a>Leetcode617.合并二叉树</h1><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">Leetcode617.合并二叉树</a></p>
<blockquote>
<p>合并二叉树 = 相加根结点值 + 合并左子树 + 合并右子树</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span>(t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line"></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">    root.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">    root.right = mergeTrees(t1.right, t2.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode112-路径总和"><a href="#Leetcode112-路径总和" class="headerlink" title="Leetcode112.路径总和"></a>Leetcode112.路径总和</h1><p><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">Leetcode112.路径总和</a></p>
<blockquote>
<p>判断是否存在一个路径和的值是给定的值</p>
<p>是否存在这样的路径 = 和减当前节点值 + 左子树是否存在这样的路径/右子树是否存在这样的路径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode437-路径总和-III"><a href="#Leetcode437-路径总和-III" class="headerlink" title="Leetcode437. 路径总和 III"></a>Leetcode437. 路径总和 III</h1><p><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">Leetcode437. 路径总和 III</a></p>
<blockquote>
<p>对于包括根的路径，可以减去根的值之后对左子树和右子树进行递归操作</p>
<p>此题不一定包括根，那么分情况为包括根和不包括根，前者用上面的方法，后者即对左子树和右子树进行递归。</p>
<p>也就是说此题通过两个递归完成。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSumStartWithRoot</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val == sum) ret++;</span><br><span class="line">    ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode572-另一个树的子树"><a href="#Leetcode572-另一个树的子树" class="headerlink" title="Leetcode572.另一个树的子树"></a>Leetcode572.另一个树的子树</h1><p><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">Leetcode572.另一个树的子树</a></p>
<blockquote>
<p>一个树是否为另一个树的子树 = 遍历所有节点使每个节点成为另一个树根节点，遍历判断是否相同。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//题中给出s，t不为空，因此无需判断t，只判断s即可</span></span><br><span class="line">    <span class="keyword">return</span> isSubtreeWithRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtreeWithRoot</span><span class="params">(TreeNode s, TreeNode t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.val != t.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtreeWithRoot(s.left, t.left) &amp;&amp; isSubtreeWithRoot(s.right, t.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode107-对称二叉树"><a href="#Leetcode107-对称二叉树" class="headerlink" title="Leetcode107.对称二叉树"></a>Leetcode107.对称二叉树</h1><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">Leetcode107.对称二叉树</a></p>
<blockquote>
<p>二叉树是否对称 = 左右子树对称</p>
<p>两棵树对称 = 树1左对称树2右 + 树1右对称树2左</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isMirror(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode t1, TreeNode t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 ==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(t1 == <span class="keyword">null</span> || t2 ==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (t1.val == t2.val) &amp;&amp; isSymmetric(t1.left, t2.right) &amp;&amp; isSymmetric(t2.left, t1.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode111-二叉树最小深度"><a href="#Leetcode111-二叉树最小深度" class="headerlink" title="Leetcode111.二叉树最小深度"></a>Leetcode111.二叉树最小深度</h1><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">Leetcode111.二叉树最小深度</a></p>
<blockquote>
<p>二叉树最小深度 = 左右子树最小深度的小值 + 1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = minDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = minDepth(root.right);</span><br><span class="line">    <span class="comment">//注意深度为0时需要单独判断，深度为0代表没有而不是为0</span></span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">0</span> || right ==<span class="number">0</span>) <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode404-左叶子之和"><a href="#Leetcode404-左叶子之和" class="headerlink" title="Leetcode404.左叶子之和"></a>Leetcode404.左叶子之和</h1><p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">Leetcode404.左叶子之和</a></p>
<blockquote>
<p> 对于左子树，要判断是否为叶子节点</p>
<p>对于右子树，直接递归</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(isLeaf(root.left)) <span class="keyword">return</span> root.left.val + sumOfLeftLeaves(root.right);</span><br><span class="line">    <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode124-二叉树的最大路径和"><a href="#Leetcode124-二叉树的最大路径和" class="headerlink" title="Leetcode124.二叉树的最大路径和"></a>Leetcode124.二叉树的最大路径和</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">Leetcode124.二叉树的最大路径和</a></p>
<blockquote>
<p>由下向上DFS求出每个节点的最大贡献</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = Math.max(dfs(root.left), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> right = Math.max(dfs(root.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    max = Math.max(max, left + right + root.val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root.val + Math.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode687-最长同值路径"><a href="#Leetcode687-最长同值路径" class="headerlink" title="Leetcode687.最长同值路径"></a>Leetcode687.最长同值路径</h1><p><a href="https://leetcode-cn.com/problems/longest-univalue-path/" target="_blank" rel="noopener">Leetcode687.最长同值路径</a></p>
<blockquote>
<p>由下向上DFS求以当前节点为一端的最长同值路径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = dfs(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = dfs(root.right);</span><br><span class="line">    <span class="keyword">int</span> leftNum = root.left != <span class="keyword">null</span> &amp;&amp; root.left.val == root.val ? left + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightNum = root.right != <span class="keyword">null</span> &amp;&amp; root.right.val == root.val ? right + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    max = Math.max(max, leftNum + rightNum);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftNum, rightNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread Local分析与扩展</title>
    <url>/2019/12/14/Thread-Local%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>ThreadLocal是一个非常重要的类，用来提供线程级别的变量，变量只对当前线程可见，记得我第一次接触时觉得，还有这种操作？每个线程有独立的属于自己的变量，相比于“使用锁控制共享变量”，ThreadLocal更加效率简单。</p>
<p>那么ThreadLocal类最重要的，就是<strong>如何让线程维护自己的变量副本</strong>。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Thread类中的相关变量"><a href="#Thread类中的相关变量" class="headerlink" title="Thread类中的相关变量"></a>Thread类中的相关变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained    </span></span><br><span class="line"><span class="comment">    * by the ThreadLocal class. */</span></span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Thread类中的变量<code>threadLocals</code>是<code>ThreadLocalMap</code>类型，而<code>ThreadLocalMap</code>就是实现ThreadLocal的重要类。</p>
<h2 id="ThreadLocalMap介绍"><a href="#ThreadLocalMap介绍" class="headerlink" title="ThreadLocalMap介绍"></a>ThreadLocalMap介绍</h2><p><code>ThreadLocalMap</code>是 <code>ThreadLocal</code>的内部类，他是类 <code>Map</code>结构，也是存储 <code>K-V</code>结构数据，并用 <code>Entry</code>封装 <code>K-V</code>。不同的是 <code>ThreadLocalMap</code>的 <code>Entry</code>的 <code>Key</code>只能是 <code>ThreadLocal</code>类型对象，并且是一个弱引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说线程通过一个类Map数据结构 <code>ThreadLocal.ThreadLocalMap</code> 来存储属于自己的线程变量。</p>
<h2 id="ThreadLocal的get与set"><a href="#ThreadLocal的get与set" class="headerlink" title="ThreadLocal的get与set"></a>ThreadLocal的get与set</h2><p><code>ThreadLocalMap</code>赋值、取值操作的入口在其外部类 <code>ThreadLocal</code>中。</p>
<p><code>set(v)</code>方法内调用 <code>ThreadLocalMap</code> 的 <code>set(this,v)</code>方法存值。（类似 <code>Map</code>的 <code>put(k,v)</code>方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>get()</code>方法内调用 <code>ThreadLocalMap</code>的 <code>getEntry(this)</code>方法取值（类似 <code>Map</code>的 <code>get(k)</code>方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代码可以看出：</p>
<ul>
<li>第一次操作线程的 <code>ThreadLocalMap</code>属性时，会初始化一个 <code>ThreadLocal.ThreadLocalMap</code>， <code>set(v)</code>会存入以参数为 <code>Value</code>的 <code>K/V</code>数据， <code>get()</code>会存入以 <code>null</code>为 <code>value</code>的 <code>K/V</code>数据。</li>
</ul>
<ul>
<li><code>ThreadLocal.ThreadLocalMap</code> 存值操作入口是 <code>ThreadLocal.set(v)</code>方法，并以当前 <code>ThreadLocal</code>变量为 <code>key</code>，参数为 <code>value</code>。</li>
<li><code>ThreadLocal.ThreadLocalMap</code> 取值操作入口是 <code>ThreadLocal.get(v)</code>方法， <code>key</code>为当前ThreadLocal变量。</li>
</ul>
<h2 id="总结ThreadLocal的实现方式"><a href="#总结ThreadLocal的实现方式" class="headerlink" title="总结ThreadLocal的实现方式"></a>总结ThreadLocal的实现方式</h2><p>起初知道<code>ThreadLocal</code>时，认为是开辟一个大的空间存储，然后保存每个元素对应的线程名，当每个线程操作变量时根据线程名进行对应更改。其实仔细想想会发现，这种想法其实是类似于最开始提到的共享空间。</p>
<p><code>ThreadLocal</code>拥有内部类<code>ThreadLocalMap</code>，以<code>ThreadLocal</code>作为key，对应的值作为value，而每个<code>Thread</code>拥有一个<code>ThreadLocalMap</code>的变量，当线程对<code>ThreadLocal</code>类型变量进行<code>get</code>和<code>set</code>时，方法会首先获取当前线程，并获得线程的<code>ThreadLocalMap</code>，从而进行<code>get</code>和<code>set</code>操作。</p>
<ul>
<li>当我们定义一个 <code>ThreadLocal</code>变量时，其实就是在定义一个 <code>Key</code>。</li>
<li>当我们调用 <code>set(v)</code>方法时，就是以当前 <code>ThreadLocal</code>变量为 <code>key</code>，传入参数为 <code>value</code>，向 <code>ThreadLocal.ThreadLocalMap</code>存数据。</li>
<li>当我们调用 <code>get()</code>方法时，就是以当前 <code>ThreadLocal</code>变量为 <code>key</code>，从 <code>ThreadLocal.ThreadLocalMap</code>取对应的数据。</li>
</ul>
<h1 id="ThreadLocalMap扩展"><a href="#ThreadLocalMap扩展" class="headerlink" title="ThreadLocalMap扩展"></a>ThreadLocalMap扩展</h1><h2 id="ThreadLocalMap的Hash冲突解决办法"><a href="#ThreadLocalMap的Hash冲突解决办法" class="headerlink" title="ThreadLocalMap的Hash冲突解决办法"></a>ThreadLocalMap的Hash冲突解决办法</h2><p>采用<strong>线性探测</strong>的方式，根据 <code>key</code>计算 <code>hash</code>值，如果出现冲突，则向后探测，当到哈希表末尾的时候再从0开始，直到找到一个合适的位置。</p>
<p>这种算法也决定了 <code>ThreadLocalMap</code>不适合存储大量数据。</p>
<h2 id="ThreadLocalMap的扩容问题"><a href="#ThreadLocalMap的扩容问题" class="headerlink" title="ThreadLocalMap的扩容问题"></a>ThreadLocalMap的扩容问题</h2><p><code>ThreadLocalMap</code>初始大小为 <code>16</code>，加载因子为 <code>2/3</code>，当 <code>size</code>大于 <code>threshold</code>时，就会进行扩容。</p>
<p>扩容时，新建一个大小为原来数组长度的<strong>两倍</strong>的数组，然后遍历旧数组中的 <code>entry</code>并将其插入到新的hash数组中，在扩容的时候，会把 <code>key</code>为 <code>null</code>的 <code>Entry</code>的 <code>value</code>值设置为 <code>null</code>，以便内存回收，减少内存泄漏问题。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>记关于Integer和int的踩坑</title>
    <url>/2019/12/11/%E8%AE%B0%E5%85%B3%E4%BA%8EInteger%E5%92%8Cint%E7%9A%84%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>某次做算法题的时候突然在考虑这个题里用List的话，需不需要考虑不把null存进去，我们知道List是允许存null的，不过这不是重点，总之不知道怎么就去用了增强for循环。</p>
<h1 id="踩坑经历"><a href="#踩坑经历" class="headerlink" title="踩坑经历"></a>踩坑经历</h1><p>使用增强for循环遍历时报了异常，然后转而直接用迭代器遍历没有报错，我们知道增强for循环属于语法糖，编译后还是使用迭代器方法进行遍历操作的，那为什么用增强for循环报错了呢？且并没有在遍历过程中进行增删操作，我们知道可以使用iterator.remove()进行操作，如果直接操作会改变迭代器，导致fail-fast。</p>
<p>很快发现了问题所在，我在foreach中使用了int而非Integer，我们知道int的默认值为0，它无法表示null，因此当定义为int，而遍历到null元素时，就会出现NullPointerException。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个更大元素</title>
    <url>/2019/12/11/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="Leetcode739-每日温度"><a href="#Leetcode739-每日温度" class="headerlink" title="Leetcode739.每日温度"></a>Leetcode739.每日温度</h1><p><strong>题目描述：</strong></p>
<p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[73, 74, 75, 71, 69, 72, 76, 73]</span><br><span class="line">输出：[1, 1, 4, 2, 1, 1, 0, 0]</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<p>根据题目的描述，实际上是找数组中元素比当前元素大的下一个元素和当前元素之间的距离，最简单的方法就是双重遍历，对于每一个元素向后遍历即可，但效率较低，例如比第一个元素大的元素在数组末尾，我们就要遍历一遍，而中间遍历的有些元素已经可以确定它的下一个更大元素的位置了，因此我们用栈保存遍历过的元素，对于当前元素和栈顶比较，大于栈顶说明当前元素是栈顶元素的下一个更大元素，为了计算距离我们保存他们的索引，时间是线性。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = T.length;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Stack&lt;Integer&gt; index = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> curIndex = <span class="number">0</span>; curIndex &lt; n; curIndex++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!index.isEmpty() &amp;&amp; T[curIndex] &gt; T[index.peek()])&#123;</span><br><span class="line">            <span class="keyword">int</span> preIndex = index.pop();</span><br><span class="line">            ans[preIndex] = curIndex - preIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        index.push(curIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>栈实现括号匹配</title>
    <url>/2019/12/11/%E6%A0%88%E5%AE%9E%E7%8E%B0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="Leetcode20-有效的括号"><a href="#Leetcode20-有效的括号" class="headerlink" title="Leetcode20.有效的括号"></a>Leetcode20.有效的括号</h1><p><strong>题目描述：</strong><br>给定一个只包括<code>&#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39;</code>的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code>输入: &quot;()&quot;
输出: true</code></pre><hr>
<pre><code>输入: &quot;()[]{}&quot;
输出: true</code></pre><hr>
<pre><code>输入: &quot;(]&quot;
输出: false</code></pre><hr>
<pre><code>输入: &quot;([)]&quot;
输出: false</code></pre><hr>
<pre><code>输入: &quot;{[]}&quot;
输出: true</code></pre><p><strong>思路：</strong></p>
<p>括号匹配是最常见的栈操作问题，在初学栈时基本都会拿括号匹配来练习，遇到左括号入栈，遇到右括号则弹出栈顶元素进行匹配，当遍历结束时栈中为空则匹配成功。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'&#123;'</span> || c == <span class="string">'['</span>) &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> cStack = stack.pop();</span><br><span class="line">            <span class="keyword">boolean</span> b1 = c == <span class="string">')'</span> &amp;&amp; cStack != <span class="string">'('</span>;</span><br><span class="line">            <span class="keyword">boolean</span> b2 = c == <span class="string">']'</span> &amp;&amp; cStack != <span class="string">'['</span>;</span><br><span class="line">            <span class="keyword">boolean</span> b3 = c == <span class="string">'&#125;'</span> &amp;&amp; cStack != <span class="string">'&#123;'</span>;</span><br><span class="line">            <span class="keyword">if</span> (b1 || b2 || b3) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最小值栈</title>
    <url>/2019/12/11/%E6%9C%80%E5%B0%8F%E5%80%BC%E6%A0%88/</url>
    <content><![CDATA[<h1 id="Leetcode155-最小栈"><a href="#Leetcode155-最小栈" class="headerlink" title="Leetcode155.最小栈"></a>Leetcode155.最小栈</h1><p><strong>题目描述：</strong></p>
<p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li>push(x) – 将元素 x 推入栈中。</li>
<li>pop() – 删除栈顶的元素。</li>
<li>top() – 获取栈顶元素。</li>
<li>getMin() – 检索栈中的最小元素。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code>MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.</code></pre><p><strong>思路：</strong></p>
<p>思考一下，当我们要寻找一个n个元素的最小值时，首先想到的就是对集合元素进行遍历，但这是效率很低的方法，因为并不是直接给了我们这样一个集合，栈中的每个元素都会经过入栈操作，那么我们可以用变量保留最小值。继续考虑，如果我们保留一个最小值，当这个最小值出栈的时候该如何做，我们又需要对栈中其他元素进行遍历才行，这样只是对于之前的方法稍微优化了一下，但仍然需要遍历操作。如果不需要遍历的话，那么我们一定需要保存多个值，也就是空间复杂度O(n)，我们可以将入栈后的元素按大小顺序保存在另一个集合里，获取最小值时直接获取集合中的最小值，出栈时集合里的元素同时出栈，但这样要求我们在集合元素出栈时可以做到O(1)，如果我们也用栈来保存这个最小值集合，与数据栈同进同出，就可以完成，保证栈每个状态都在最小值栈有对应的状态即可。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        dataStack.push(x);</span><br><span class="line">        min = Math.min(min, x);</span><br><span class="line">        minStack.push(min);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minStack.pop();</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列相互实现</title>
    <url>/2019/12/10/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9B%B8%E4%BA%92%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Leetcode232-用栈实现队列"><a href="#Leetcode232-用栈实现队列" class="headerlink" title="Leetcode232.用栈实现队列"></a>Leetcode232.用栈实现队列</h1><p><strong>题目描述：</strong></p>
<p>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) – 将一个元素放入队列的尾部。</li>
<li>pop() – 从队列首部移除元素。</li>
<li>peek() – 返回队列首部的元素。</li>
<li>empty() – 返回队列是否为空。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code>MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);  
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false</code></pre><p><strong>思路：</strong></p>
<p>栈与队列的区别就是栈是先进后出的数据结构，在一端进行操作，队列是先进先出，在两端进行操作，因此我们使用两个栈来实现队列的操作，一个栈进行push操作，当需要pop时将in栈中元素加入out，即元素进入in后又出来进入out，这样操作使得out栈中出栈的顺序恰好是元素进栈顺序，实现了先进先出，当out栈空时进行换栈操作。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; in;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.pop(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">in2out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!in.isEmpty())&#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode225-用队列实现栈"><a href="#Leetcode225-用队列实现栈" class="headerlink" title="Leetcode225.用队列实现栈"></a>Leetcode225.用队列实现栈</h1><p><strong>题目描述：</strong></p>
<p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) – 元素 x 入栈</li>
<li>pop() – 移除栈顶元素</li>
<li>top() – 获取栈顶元素</li>
<li>empty() – 返回栈是否为空</li>
</ul>
<p><strong>思路：</strong></p>
<p>与栈实现队列类似，首先能想到的就是利用两个队列来做，一个队列维护入栈，当需要出栈时将其他元素加入另一个队列，并将两个队列的作用互换。</p>
<p>然而其实一个队列就可以实现栈操作，这与栈实现队列不同之处在于，栈是一个一端操作的数据结构，我们用一个栈无论如何也没办法完成队列操作，但队列是两端操作，用一个队列完全可以实现栈操作，每次需要出栈时将除最后一个元素外的其他元素出队再入队即可，或是入栈时将其他元素出队再入队，出栈直接出，效果相同。(因为要获取栈顶元素，所以最好还是在进队的时候就进行操作)</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">        <span class="keyword">while</span>(cnt-- &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            queue.add(queue.remove());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>Leetcode</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2019/12/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>单例模式是一种最简单的设计模式，指对于一个类，在整个程序中仅有一个实类，其他类访问的都是同一个实例。</p>
<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><blockquote>
<p>单例模式分为饿汉式和懒汉式</p>
</blockquote>
<p>单例模式一般分为三部分：</p>
<ul>
<li>构造函数私有化</li>
<li>类的实例成员变量</li>
<li>调用类的实例的方法</li>
</ul>
<h2 id="饿汉式单例模式写法"><a href="#饿汉式单例模式写法" class="headerlink" title="饿汉式单例模式写法"></a><strong>饿汉式单例模式写法</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顾名思义饿汉式即非常饥饿，无论是否用到此类，都生成类的实例，在类初始化时即被创建，不存在线程安全问题，但如果程序中没有使用到该类，会造成空间浪费。</p>
<h2 id="懒汉式单例模式写法"><a href="#懒汉式单例模式写法" class="headerlink" title="懒汉式单例模式写法"></a><strong>懒汉式单例模式写法</strong></h2><h3 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a><strong>写法一</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顾名思义懒汉式即很懒，直到需要类实例的时候才去创建它，上面是懒汉式最简单的写法，但很明显无法保证线程安全，当一个线程进入if判断但并未创建实例时，另一个线程也同时进入了if判断，会导致创建两个不同的实例，违背了单例模式设计原则。</p>
<h3 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a><strong>写法二</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程不安全？那把方法改为同步方法即可，但想想看，这样的话每次访问都需要同步进行，而实际上我们只需要一次同步操作，即当实例未被创建时，此后的同步操作是无意义的。</p>
<h3 id="写法三"><a href="#写法三" class="headerlink" title="写法三"></a><strong>写法三</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为对类对象进行加锁，同时使用了双重检验，因为如果一次判断的话，仍然会出现两个线程同时进入if判断里，只是其中一个要等待锁，结果还是创建了两个对象，双重判定避免了这种情况，但仍存在问题，我们知道JVM的引用赋值操作并非原子操作，而是分为<code>分配对象内存空间</code>、<code>初始化对象</code>、<code>将引用指向分配的内存地址</code>，而执行时会因为JVM优化导致指令重排序，例如可能先指向内存地址，再初始化对象，如果线程1的执行顺序为1-3-2，当线程正在进行了步骤3但还未完成步骤2的执行时，线程2调用<code>getInstance()</code>方法，此时<code>instance</code>不为<code>null</code>，因此返回了并未初始化完成的实例，这就是双重检查锁导致的问题。</p>
<h3 id="写法四"><a href="#写法四" class="headerlink" title="写法四"></a><strong>写法四</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用volatile关键字禁止指令重排，保证在写操作没有完成之前不能调用读操作。volatile的两个特性一个是可见性另一个是有序性。此方法适用于JDK1.5以后。</p>
<h3 id="写法五"><a href="#写法五" class="headerlink" title="写法五"></a><strong>写法五</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用静态内部类的特点实现懒加载，在调用<code>getInstance之前不会对</code>SingletonHolder`进行初始化。</p>
<h3 id="写法六"><a href="#写法六" class="headerlink" title="写法六"></a><strong>写法六</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingleTon&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类的创建是线程安全的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>链表求和</title>
    <url>/2019/12/09/%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<p><strong>题目描述：</strong></p>
<p>给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。<br><strong>示例：</strong></p>
<pre><code>输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出: 7 -&gt; 8 -&gt; 0 -&gt; 7</code></pre><p><strong>思路：</strong></p>
<p>两个数按位置相加，需要考虑的就是进位，还有链表长度不一的情况，因为要从链表末尾开始操作，我们需要先对链表进行反转，题目中问到了链表不能翻转如何操作，我使用了将节点入栈的方法，但本质上也是翻转，每次从栈中取出2个数相加，保留进位即可，栈不空则继续，同时要考虑最后栈空但还有进位的情况。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1 = buildStack(l1);</span><br><span class="line">    Stack&lt;Integer&gt; s2 = buildStack(l2);</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!s1.isEmpty() || !s2.isEmpty() || carry != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = s1.isEmpty() ? <span class="number">0</span> : s1.pop();</span><br><span class="line">        <span class="keyword">int</span> y = s2.isEmpty() ? <span class="number">0</span> : s2.pop();</span><br><span class="line">        <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Stack&lt;Integer&gt; <span class="title">buildStack</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(node.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <url>/2019/12/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="Leetcode-19删除链表的倒数第N个节点"><a href="#Leetcode-19删除链表的倒数第N个节点" class="headerlink" title="Leetcode.19删除链表的倒数第N个节点"></a>Leetcode.19删除链表的倒数第N个节点</h1><p><strong>题目描述：</strong></p>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p><strong>示例：</strong></p>
<pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</code></pre><p><strong>思路：</strong></p>
<p>如果是数组删除某个位置的元素可以直接访问，对于链表我们则需要遍历，但因为是倒数，我们没办法确定遍历到哪里，链表也非双向，因此首先能想到的就是两次遍历，第一次遍历确定链表长度，得到需要删除的节点位置，第二次遍历删除。</p>
<p>但是对于链表问题，经常有更好的方法，这个题可以使用双指针，使用两次遍历是因为我们无法确定在一次遍历时该在何处停止，原因是因为不知道链表有多长，那么我们只要让一个指针先移动n步，然后让一个新指针开始同时从头走，当前一个指针遍历结束后，后一个指针的位置就是我们要删除节点的前一节点，将它指向下下个节点即可。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode pre = head;</span><br><span class="line">    ListNode next = head;</span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="keyword">null</span>) <span class="keyword">return</span> head.next;</span><br><span class="line">    <span class="keyword">while</span>(pre.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    next.next = next.next.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这个题给定n是有效的，所以没有过多考虑代码的鲁棒性，如果不确定n是否有效，例如n大于链表长度，我们需要在循环中判断是否已经遍历到了尾部。</p>
<p>另外，在pre遍历结束后判断了pre为null的情况，此时要删除的是第一个节点，因为第一个节点没有上一个节点所以需要单独判断，我们也可以为链表添加一个哑节点，使得能删除的每个节点都有上一个节点。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池的使用</title>
    <url>/2019/12/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h1><p>就不贴什么定义了，用自己的理解说一下，线程池就是维护了一定量线程用来执行任务，我们要创建线程执行任务时，直接将任务交给线程池，线程池分配给线程池中的线程去执行，可以对线程池中的线程进行分配和回收，不需要每次都创建新的线程，基本所有的池作用都类似，例如数据库连接池之类的。</p>
<h1 id="使用线程池的优点"><a href="#使用线程池的优点" class="headerlink" title="使用线程池的优点"></a>使用线程池的优点</h1><ul>
<li><p>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p>
</li>
<li><p>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止消耗过多的内存</p>
</li>
<li><p>方便管理，可以将一个线程池交给容器去管理</p>
</li>
</ul>
<h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>ThreadPoolExecutor类实现Executor和ExecutorService接口，是线程池操作的基本类，常用的四种线程池底层都是对ThreadPoolExecutor的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>corePoolSize 核心线程数，指保留的线程池大小（不超过maximumPoolSize值时，线程池中最多有corePoolSize 个线程工作）。</p>
</li>
<li><p>maximumPoolSize 指的是线程池的最大大小（线程池中最大有corePoolSize 个线程可运行）</p>
</li>
<li><p>keepAliveTime 指的是空闲线程结束的超时时间（当一个线程不工作时，过keepAliveTime 长时间将停止该线程）。</p>
</li>
<li><p>unit 是一个枚举，表示 keepAliveTime 的单位（有NANOSECONDS, MICROSECONDS,</p>
</li>
</ul>
<p>MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS，7个可选值）。</p>
<ul>
<li><p>workQueue 表示存放任务的队列（存放需要被线程池执行的线程队列）。</p>
</li>
<li><p>threadFactory 执行程序创建新线程时使用的工厂。</p>
</li>
<li><p>handler 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。</p>
</li>
</ul>
<h1 id="四种线程池"><a href="#四种线程池" class="headerlink" title="四种线程池"></a>四种线程池</h1><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><strong>newSingleThreadExecutor</strong></h2><blockquote>
<p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此线程池核心线程为1，不回收线程，使用<code>LinkedBlockingQueue</code>且无参数，即线程队列的大小为<code>Integer.MAX_VALUE</code>，当有任务在执行时，其余任务全都会存放在队列中等待执行。</p>
<h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><strong>newFixedThreadPool</strong></h2><blockquote>
<p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line"> <span class="number">0L</span>,TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>相比于<code>newSingleThreadExecutor</code>，允许传入参数来创建固定大小的线程池，其余无区别，即传入参数为1时相当于<code>newSingleThreadExecutor</code></p>
<h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><strong>newCachedThreadPool</strong></h2><blockquote>
<p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到核心线程为0，但允许最大线程为<code>Integer.MAX_VALUE</code>，且闲置经过60s的线程会被回收，即可以根据任务数量来调整线程池的线程数量，使用<code>SynchronousQueue</code>队列，此队列内部没有数据缓存空间，生产者和消费者互相等待，等到对方之后然后再一起离开，也就是说队列中不排队存放任务，每个任务都会交给线程池进行处理。</p>
<h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a><strong>newScheduledThreadPool</strong></h2><blockquote>
<p>具有定时定期执行任务功能的线程池。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">            DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心线程固定，最大线程无穷大，但非核心线程闲置后会被立即回收，可以通过<code>schedule()</code>等方法启动，进行延迟操作。</p>
<h1 id="无法处理线程时的Handler"><a href="#无法处理线程时的Handler" class="headerlink" title="无法处理线程时的Handler"></a>无法处理线程时的Handler</h1><blockquote>
<p>RejectedExecutionHandler接口提供了对于拒绝任务的处理的自定方法的机会。在ThreadPoolExecutor中已经默认包含了4中策略。</p>
</blockquote>
<ul>
<li><p>CallerRunsPolicy（直接运行run方法）：线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</p>
</li>
<li><p>AbortPolicy（抛异常）：处理程序遭到拒绝将抛出运行时RejectedExecutionException。</p>
</li>
<li><p>DiscardPolicy（直接丢弃）：不能执行的任务将被删除。</p>
</li>
<li><p>DiscardOldestPolicy（抛弃最老的线程）：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序链表</title>
    <url>/2019/12/06/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="Leetcode21-合并两个有序链表"><a href="#Leetcode21-合并两个有序链表" class="headerlink" title="Leetcode21.合并两个有序链表"></a>Leetcode21.合并两个有序链表</h1><p><strong>题目描述：</strong></p>
<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例：</strong></p>
<pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><p><strong>思路：</strong></p>
<p>第一种思路就像合并两个有序数组一样，不断的判断大小放进新数组就好了，这种就是要考虑当其中一个为空的情况，直接把另一个加入到新的里。</p>
<p>第二种就是递归，将一个节点加入新链表后，又变成了合并两个有序链表的问题，两种思路流程差不多。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode cur = pre;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &gt; l2.val)&#123;</span><br><span class="line">            val = l2.val;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            val = l1.val;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) cur.next = l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) cur.next = l1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pre.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种思路第一点要注意一个链表已经遍历完成后的处理，第二点是对于新链表需要两个引用，一个指向头，一个指向当前要加入的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归的代码就比较简洁。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2019/12/06/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="Leetcode206-反转链表"><a href="#Leetcode206-反转链表" class="headerlink" title="Leetcode206.反转链表"></a>Leetcode206.反转链表</h1><p><strong>题目描述：</strong></p>
<p>反转一个单链表。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p><strong>思路：</strong></p>
<p>反转链表也是一个比较有代表性的链表操作，因为链表的特性，所以很多链表题都可以通过递归来完成，反转链表可以通过递归和迭代来完成。</p>
<p>对于递归操作，反转当前节点后的链表，然后要把当前节点加到链表尾部去，也就是说我们要有尾部节点的引用，恰好反转后尾部节点就是反转前当前节点的下一节点，也就是当前节点的next</p>
<p>对于迭代操作，我们需要把当前节点的next指向上一节点即可，这里要注意的就是，如果直接把当前节点指向上一节点，我们就会丢失之后的链表引用，所以要提前保存之后的节点。</p>
<p><strong>代码：</strong></p>
<p>递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.next;<span class="comment">//先保存之后的链表部分</span></span><br><span class="line">        cur.next = pre;<span class="comment">//反转当前节点</span></span><br><span class="line">        pre = cur;<span class="comment">//当前节点成为上一节点</span></span><br><span class="line">        cur = next;<span class="comment">//下一节点成为当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代这里可以不用声明那么多节点，但是为了清晰还是多声明点，迭代相比递归，更考验对链表操作的熟悉程度。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>相交链表</title>
    <url>/2019/12/06/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="Leetcode160-相交链表"><a href="#Leetcode160-相交链表" class="headerlink" title="Leetcode160.相交链表"></a>Leetcode160.相交链表</h1><p><strong>题目描述：</strong></p>
<p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p><strong>示例：</strong></p>
<pre><code>A:          a1 → a2
                    ↘
                    c1 → c2 → c3
                    ↗
B:    b1 → b2 → b3</code></pre><p>例如对于A，B链表，返回c1节点</p>
<p><strong>思路：</strong></p>
<p>看到这个题最直接的想法就是遍历，但仔细想想遍历的话我们需要遍历A中每一个节点，然后判断它是否和B中一个节点相同，时间复杂度O(mn)，显然不是好算法，第二种想法可以遍历A中节点，并存在哈希表中，这样同样是遍历，但是哈希表查找的时间复杂度O(1)，可以让算法时间复杂度成为O(m+n)，自己觉得这个方法已经比较好了，因为是线性时间，但是还是有更好的方法，线性时间且空间复杂度为O(1)。</p>
<p>我们设A链表长度为a + c，B链表长度为b + c，A和B的遍历长度不定，但A+B的遍历长度是一样的，我们用两个指针，一个按AB顺序遍历，一个按BA顺序遍历，也就是a + c + b + c，另一个b + c + a + c，从这里可以看出，当两个指针都走a + b + c时，它们可以同时到达相交节点，这个节点就是结果。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(headA != <span class="keyword">null</span>)&#123;</span><br><span class="line">        set.add(headA);</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(headB != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(headB)) <span class="keyword">break</span>;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    ListNode l1 = headA;</span><br><span class="line">    ListNode l2 = headB;</span><br><span class="line">    <span class="keyword">while</span>(l1 != l2)&#123;</span><br><span class="line">        l1 = (l1 == <span class="keyword">null</span>) ? headB : l1.next;</span><br><span class="line">        l2 = (l2 == <span class="keyword">null</span>) ? headA : l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于最后这种遍历方式，记得之前做链表中环找环节点的时候也遇到过，遇到链表找节点的题可以多思考思考不同的遍历方式，尤其很多时候需要两个指针。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet源码阅读</title>
    <url>/2019/12/06/HashSet%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<pre><code>HashSet也是Set集合中用的比较多的，所以也读一读源码。</code></pre><h1 id="HashSet的特点"><a href="#HashSet的特点" class="headerlink" title="HashSet的特点"></a>HashSet的特点</h1><ul>
<li>存入元素不能重复</li>
<li>存入元素无序</li>
<li>可以存null</li>
</ul>
<h1 id="核心成员变量"><a href="#核心成员变量" class="headerlink" title="核心成员变量"></a>核心成员变量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashSet底层是基于HashMap存储数据，该map的key就是HashSet要存放的数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="comment">//该变量用来填充上一个map的value字段，因为HashSet关注的是map的Key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p>HashSet的底层是通过HashMap实现的，HashSet存放的实际数据也就是HashMap的key，调用无参构造方法时，会实例化一个HashMap对象。</p>
<h1 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加一个元素，如果该元素已经存在，则返回true，如果不存在，则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//往map中添加元素，返回null，说明是第一个往map中添加该key</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>往hashSet中添加元素，实际是往map成员变量里面添加对应的key和value；</li>
<li>map中的key实际就是要添加的元素，value是一个固定的对象；</li>
<li>当第一次往map中添加key时，添加成功返回null，所以当第一次往hashSet中添加元素时，会返回true；</li>
<li>由于hashMap中的key不能重复，所以hashSet不能存储重复元素。</li>
</ul>
<h1 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除指定的元素，删除成功返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实际是删除map中的一个对象</span></span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当hashSet删除一个元素时，实际是操作map删除对应的元素；</li>
<li>当删除map中一个不存在的对象是，会返回null，所以这里当返回PERSENT时，说明之前hashSet往map中添加过对应的元素，因此，当remove(o)返回true时，说明之前已经存在该元素，并且成功删除；当返回false时，说明之前并没有添加过该对象；</li>
</ul>
<h1 id="Iterator-方法实现"><a href="#Iterator-方法实现" class="headerlink" title="Iterator()方法实现"></a>Iterator()方法实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取hashSet的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用map获取keySet</span></span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashset获取迭代器实际是获取map的keySet的iterator；</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说只要知道HashSet底层是通过HashMap来实现的就好了，HashSet的一些方法基本也是对HashMap实例的操作和方法调用，然后了解HashSet的一些特点，并且因为HashSet不提供get方法，所以获取数据的话可以通过Iterator获取。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>容器集合</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>GROUP BY的用法问题</title>
    <url>/2019/12/05/GROUP-BY%E7%9A%84%E7%94%A8%E6%B3%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<pre><code>在牛客做SQL题遇到了一个问题，这篇博客记录一下，也做个提醒。</code></pre><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary<br>（当前表示的是to_date = ‘9999-01-01’的行数据）</p>
<pre><code>CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));</code></pre><h1 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h1><p><img src="https://user-images.githubusercontent.com/45253106/70237603-8747ec80-17a2-11ea-8526-8014435b3323.png" alt="image"></p>
<h1 id="解答与问题"><a href="#解答与问题" class="headerlink" title="解答与问题"></a>解答与问题</h1><p>我第一次写出的答案是这样的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.dept_no,d.emp_no,<span class="keyword">MAX</span>(s.salary) <span class="keyword">AS</span> salary</span><br><span class="line"><span class="keyword">FROM</span> dept_emp <span class="keyword">AS</span> d</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">ON</span> d.emp_no = s.emp_no <span class="keyword">AND</span> d.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">AND</span> s.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> d.dept_no</span><br></pre></td></tr></table></figure>
<p>SELECT了没有GROUP BY的列，显然这样应该不行，但是通过了！</p>
<p>了解了一下牛客好像是SQLite判的，好像允许这样，但即使允许，我也不知道为什么它自动匹配了MAX(s.salary)对应的那个emp_no，好像也是SQLite的特性。</p>
<p>因为自己用Mysql比较多，就去查了一下，Mysql5.7之后的版本也可以SELECT没有GROUP BY的列，但不能像上面那样自动匹配，而低版本不允许SELECT没有GROUP BY的列。</p>
<p>况且这个题就算可以SELECT没有GROUP BY的列，用Mysql按上面的方式写依然是错误的，而且上面的写法也没有考虑万一有几个人都是最高薪水的情况，实际场景中几个人工资一样也很正常。</p>
<p>那么如果我们要用Mysql完成的话，首先确定的是我们可以SELECT出dept_on和对应的最大薪水，将它作为临时表，然后我们再连接一次得到员工编号emp_no，问题又来了，如果我们直接和salaries表进行连接的话，因为salaries中没有部门信息，我们连接会直接选出薪水是那几个值的所有人，但这些人并不一定在对应部门，可能有人是自己部门的非最高薪，但恰好是别的部门的最高薪，所以我们还需要建立一个临时表保存员工是哪个部门并且薪资是多少，好在这个操作和第一个临时表是一样的，只是SELECT的列不同，然后我们得到了如下的Mysql语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> maxs.dept_no,curr.emp_no,curr.salary</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(<span class="keyword">SELECT</span> d.dept_no, <span class="keyword">MAX</span>(s.salary)  salary</span><br><span class="line"><span class="keyword">FROM</span> dept_emp  d</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries  s</span><br><span class="line"><span class="keyword">ON</span> d.emp_no = s.emp_no <span class="keyword">AND</span> d.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">AND</span> s.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> d.dept_no)  maxs</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">(<span class="keyword">SELECT</span> d.dept_no, d.emp_no,s.salary</span><br><span class="line"><span class="keyword">FROM</span> dept_emp  d</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries  s</span><br><span class="line"><span class="keyword">ON</span> d.emp_no = s.emp_no <span class="keyword">AND</span> d.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">AND</span> s.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line">)  curr</span><br><span class="line"><span class="keyword">ON</span> maxs.dept_no = curr.dept_no <span class="keyword">AND</span> maxs.salary = curr.salary</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> maxs.dept_no</span><br></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="https://user-images.githubusercontent.com/45253106/70238789-f8889f00-17a4-11ea-8e08-00d19b5ca80b.png" alt="image"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个题首先让我加深了对GROUP BY的概念，虽然很多数据库允许去SELECT没有被GROUP BY的列，但我们还是应该多加注意尽量避免。</p>
<p>以后业务里也难免会遇到上述的情况，如何更简洁高效的获得正确结果，仍然需要打好基础，并且多思考优化问题。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式-动态代理-AOP</title>
    <url>/2019/12/05/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<pre><code>本篇博客总结一下关于代理模式的内容，认识AOP以后才知道是由动态代理实现的，从什么是代理模式。到静态代理和动态代理，到动态代理实现拦截器。</code></pre><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><img src="https://user-images.githubusercontent.com/45253106/70206721-69a76280-1763-11ea-8852-9ffa821518ea.png" alt="image"></p>
<a id="more"></a>

<p>代理模式中的角色：</p>
<ul>
<li><strong>抽象主题角色（Subject）</strong>：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。</li>
<li><strong>具体主题角色（RealSubject)</strong>：也称为委托角色或者被代理角色。定义了代理对象所代表的目标对象。</li>
<li><strong>代理主题角色（Proxy)</strong>：也叫委托类、代理类。代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。</li>
</ul>
<h1 id="静态代理和动态代理"><a href="#静态代理和动态代理" class="headerlink" title="静态代理和动态代理"></a>静态代理和动态代理</h1><p>代理模式又分为静态代理和动态代理。静态代理是由程序员创建或特定工具自动生成源代码，在对其编译。在程序员运行之前，代理类.class文件就已经被创建了。动态代理是在程序运行时，通过运用反射机制动态的创建而成。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>1.Subject接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.RealSubject</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RealSubject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.Proxy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subject == <span class="keyword">null</span>)</span><br><span class="line">            subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        System.out.print(<span class="string">"I'm Proxy, I'm invoking..."</span>);</span><br><span class="line">        <span class="keyword">this</span>.subject.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Subject subject = <span class="keyword">new</span> Proxy();</span><br><span class="line">subject.operate();</span><br></pre></td></tr></table></figure>

<p>输出</p>
<blockquote>
<p>I’m Proxy, I’m invoking…RealSubject</p>
</blockquote>
<p>以上就是一个静态代理，目标类和代理类实现同一个接口，代理类调用目标类的方法，可以在前后加上代码，也就是要实现的代理内容。</p>
<h3 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h3><ul>
<li>代码重复，如果目标对象的很多方法都需要代理，则需要在每一个方法上加上代理的代码。</li>
<li>对于每一个目标对象都要创建对应的代理。</li>
<li>如果接口有变动，真实主题和代理类同时都要修改，不利于维护。</li>
</ul>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是指在运行时，动态生成代理类。即，代理类的字节码将在运行时生成并载入当前的ClassLoader。也就是说动态代理是通过Java中的反射机制完成的。</p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>Jdk的动态代理是基于接口的。现在想要为RealSubject这个类创建一个动态代理对象，Jdk主要会做一下工作：</p>
<ul>
<li>获取RealSubject上的所有接口列表</li>
<li>确定要生成的代理类的类名，默认为：com.sun.proxy.$ProxyXXXX；</li>
<li>根据需要实现的接口信息，在代码中动态创建该Proxy类的字节码；</li>
<li>将对应的字节码转换为对于的class对象；</li>
<li>创建InvocationHandler实例handler,用来处理Proxy所有方法的调用；</li>
<li>Proxy的class对象以创建的handler对象为参数，实例化一个proxy对象；</li>
</ul>
<p>1.Subject</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">operate1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">operate2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">operate3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">operate4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">operate5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.RealSubject</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject1</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject-operate1()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject-operate2()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject-operate3()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject-operate4()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate5</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject-operate5()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject2</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject2-operate1()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject2-operate2()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject2-operate3()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject2-operate4()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate5</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject2-operate5()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.Proxy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newProxyInstance</span><span class="params">(Object realObj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = realObj;</span><br><span class="line">        Class&lt;?&gt; classType = <span class="keyword">this</span>.obj.getClass();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(classType.getClassLoader(), classType.getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"I'm Proxy, I'm invoking..."</span>);</span><br><span class="line">        Object object = method.invoke(obj, args);</span><br><span class="line">        System.out.println(object);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Subject object = <span class="keyword">new</span> RealSubject();</span><br><span class="line">Subject subject = (Subject) <span class="keyword">new</span> ProxyHandler()  </span><br><span class="line">          .newProxyInstance(<span class="keyword">new</span> RealSubject());</span><br><span class="line">Subject subject2 = (Subject) <span class="keyword">new</span> ProxyHandler() </span><br><span class="line">          .newProxyInstance(<span class="keyword">new</span> RealSubject2());</span><br><span class="line">subject.operate2();</span><br><span class="line">subject2.operate4();</span><br></pre></td></tr></table></figure>

<p>输出</p>
<pre><code>I&apos;m Proxy, I&apos;m invoking...RealSubject-operate2()
I&apos;m Proxy, I&apos;m invoking...RealSubject2-operate4()</code></pre><p>考虑一下如果上面这个实例用静态代理来实现，要写两个代理类，每个代理类五个方法，非常麻烦，而且如果接口改成10个方法，不仅实现类要改，代理类也要改，而按照上面动态代理的方法，我们的代理类完全不需要更改。</p>
<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>JDK的动态代理依靠接口实现，但有些类并不实现接口，就无法使用JDK代理，Spring的AOP同时使用JDK和CGLIB动态代理，取决于类是否实现了接口。</p>
<p>CGLIB是针对类来实现的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</p>
<p>CGLIB创建某个类A的动态代理类的模式是：</p>
<ul>
<li>查找A上的所有非final的public类型的方法定义</li>
<li>将这些方法的定义转换成字节码</li>
<li>将组成的字节码转换成相应的代理的class对象</li>
<li>实现MethodInterceptor接口，用来处理对代理类上所有方法的请求（这个接口和Jdk动态代理InvocationHandler的功能和角色是一样的）</li>
</ul>
<p>1.RealSubject</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubjectCglib</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubjectCglib"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.Proxy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCglib</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">//Cglib中的加强器，用来创建动态代理</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置要创建动态代理的类</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        <span class="comment">//设置回调，这里相当于是对于代理类上所有方法的调用，都会调用Callback，而Callback则需要实现intercept()方法进行拦截</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        Object obj = enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"I'm Proxy, I'm invoking..."</span>);</span><br><span class="line">        Object object = proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(object);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProxyCglib proxy = <span class="keyword">new</span> ProxyCglib();</span><br><span class="line">RealSubjectCglib cglib = (RealSubjectCglib)proxy.getInstance(<span class="keyword">new</span> RealSubjectCglib());</span><br><span class="line">cglib.operate();</span><br></pre></td></tr></table></figure>

<p>输出</p>
<blockquote>
<p>I’m Proxy, I’m invoking…RealSubjectCglib</p>
</blockquote>
<h1 id="拦截器的实现"><a href="#拦截器的实现" class="headerlink" title="拦截器的实现"></a>拦截器的实现</h1><p>我们经常说AOP是用动态代理实现的，拦截器其实也是对AOP的一种具体实现。在SpringMVC中，拦截器可以通过继承<code>HandlerInterceptorAdapter</code>实现一个拦截器。</p>
<p>关于拦截器的实现，可以看<a href="https://blog.csdn.net/westos_linux/article/details/79103627" target="_blank" rel="noopener">拦截器与动态代理的实现</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实自己最开始了解的是AOP，那时候还不知道代理模式的概念，只是知道Spring中要做日志的话用AOP，代码按照规则写，但完全不懂原理，后来接触到SpringMVC中的拦截器，觉得也是一种AOP，但也是云里雾里，然后了解了代理模式的概念，学习了静态代理和动态代理，才真正明白了AOP的实现方式和原理。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
        <tag>动态代理</tag>
        <tag>拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title>回文字符串</title>
    <url>/2019/12/04/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="Leetcode5-最长回文子串"><a href="#Leetcode5-最长回文子串" class="headerlink" title="Leetcode5.最长回文子串"></a>Leetcode5.最长回文子串</h1><p><strong>题目描述：</strong></p>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot; 也是一个有效答案。</code></pre><hr>
<pre><code>输入: &quot;cbbd&quot;
输出: &quot;bb&quot;</code></pre><p><strong>思路：</strong></p>
<p>回文字符串属于一类题型，常用的方法就是动态规划和中心扩展，还有著名的马拉车算法可以把时间复杂度降低到线性，这两道题一个用动态规划一个用中心扩展。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; s.length(); j++)&#123;</span><br><span class="line">            dp[i][j] = (s.charAt(i) == s.charAt(j)) &amp;&amp; (j - i &lt; <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; (j - i &gt;= end - start))&#123;</span><br><span class="line">                start = i;</span><br><span class="line">                end = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划重要的就是dp公式，这里dp[i][j]表示字符串从i到j是不是回文串，那么它决定于[i + 1][j - 1]，dp另一点就是初始化，在这里应该是长度为1和2的回文串，这里用条件<code>j - i &lt; 2</code>同时做初始化。</p>
<p>因为我们返回时调用了<code>substring()</code>，所以要先判断字符串长度是否为0，另一种方法我们可以直接返回一个字符串，对这个字符串做初始化，将代码里给start，end赋值的地方用<code>substring()</code>来赋值字符串，这样的话就不需要做最初的判断，但是需要多次调用<code>substring()</code>。</p>
<p>写完以后看了看其他解析，发现这个空间复杂度可以降低到O(n)，这里就不改了，主要是总结字符串，以后总结动态规划再仔细探讨这个问题，动态规划很多时候都可以优化空间，因为很多时候我们只需要一行的内容而不是全部。</p>
<h1 id="Leetcode647-回文子串"><a href="#Leetcode647-回文子串" class="headerlink" title="Leetcode647.回文子串"></a>Leetcode647.回文子串</h1><p><strong>题目描述：</strong></p>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: &quot;abc&quot;
输出: 3
解释: 三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.</code></pre><hr>
<pre><code>输入: &quot;aaa&quot;
输出: 6
说明: 6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</code></pre><p><strong>思路：</strong></p>
<p>和上一个题类似，这个题用中心扩展法来做，对于一个长度为n的字符串应该有2n-1个中心，因为中心可能是某个下标或是两个下标的中间，对应<code>&quot;aba&quot;,&quot;abba&quot;</code>两种情况.</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        centerSpread(s, i, i);</span><br><span class="line">        centerSpread(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">centerSpread</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">        right++;</span><br><span class="line">        left--;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码部分分析</title>
    <url>/2019/12/03/ArrayList%E6%BA%90%E7%A0%81%E9%83%A8%E5%88%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<pre><code>平常做算法题或者编程时常用ArrayList，所以最近也看了看ArrayList的源码，加深理解，并学习一些新内容，以下记录一些在阅读过程中理解的部分内容，像插入删除没什么特别的地方就不多描述了。</code></pre><h1 id="ArrayList的特点"><a href="#ArrayList的特点" class="headerlink" title="ArrayList的特点"></a>ArrayList的特点</h1><blockquote>
<p>在阅读源码之前自己想着写的</p>
</blockquote>
<ul>
<li>动态数组实现的变长集合</li>
<li>允许存放空值</li>
<li>允许存放重复元素</li>
<li>查找复杂度O(1)</li>
<li>插入删除性能较差</li>
<li>非线程安全</li>
</ul>
<a id="more"></a>

<h1 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h1><p>ArrayList的默认容量是10，但并不是会自动创建大小为10的数组，如果我们使用无参构造方法，创建的是空数组，在进行插入操作时，扩容机制会按照默认值重新初始化数组，扩容是1.5倍，但不绝对，至于为什么是1.5我也不是很清楚，应该也是基于时间效率和空间的考量，过小会频繁扩容，执行数组复制，过大可能会浪费很多空间。</p>
<p>下面看一下扩容的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 计算最小容量 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 扩容的入口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 扩容的核心方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// newCapacity = oldCapacity + oldCapacity / 2 = oldCapacity * 1.5</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// 如果最小容量超过 MAX_ARRAY_SIZE，则将数组容量扩容至 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到扩容核心方法grow()中也存在几种情况，最基本的是<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是1.5倍扩容，移位运算比乘除运算要高效，当新容量仍小于最小容量时，会直接将新容量更新为最小容量，例如默认容量是10，首次扩容时旧容量为0，会直接更新为10，如果扩容后超过<code>MAX_ARRAY_SIZE</code>，则最大扩充至<code>Integer.MAX_VALUE</code>，如果扩容使得minCapacity会溢出而小于0触发<code>OutOfMemoryError()</code>。</p>
<h1 id="缩容机制"><a href="#缩容机制" class="headerlink" title="缩容机制"></a>缩容机制</h1><p>ArrayList并没有提供自动缩容机制，因此如果大量插入元素之后又大量删除元素，会出现很多空闲位置且不能释放造成浪费，这时我们可以进行手动触发缩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><p>ArrayList 实现了 RandomAccess 接口（该接口是个标志性接口），表明它具有随机访问的能力。ArrayList 底层基于数组实现，所以它可在常数阶的时间内完成随机访问，效率很高。对 ArrayList 进行遍历时，一般有如下两种方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">    <span class="comment">//use</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为ArrayList的随机访问能力，用第二种方法更快，但实际测试会发现两种方法效率相差较小，一般用foreach即可，代码简洁不易出错，当然如果是LinkedList，效率相差很大，避免使用get()。</p>
<h1 id="遍历时删除"><a href="#遍历时删除" class="headerlink" title="遍历时删除"></a>遍历时删除</h1><p>不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。</p>
<p>原因：foreach的本质其实还是Iterator，遍历时会通过判断size大小判断是否有下一个元素，因此进行插入删除操作会出现问题，需要使用Iterator提供的remove方法。</p>
<h1 id="快速失败机制"><a href="#快速失败机制" class="headerlink" title="快速失败机制"></a>快速失败机制</h1><p>ArrayList 迭代器中的方法都是均具有快速失败的特性，当遇到并发修改的情况时，迭代器会快速失败，以避免程序在将来不确定的时间里出现不确定的行为。</p>
<p>java的集合框架很多都是快速失败机制，并发操作时尽量使用<code>java.util.concurrent</code>包中的类，它们是安全失败的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>容器集合</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的字母异位词</title>
    <url>/2019/12/03/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="Leetcode242-有效的字母异位词"><a href="#Leetcode242-有效的字母异位词" class="headerlink" title="Leetcode242.有效的字母异位词"></a>Leetcode242.有效的字母异位词</h1><p><strong>题目描述：</strong></p>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;
输出: true</code></pre><hr>
<pre><code>输入: s = &quot;rat&quot;, t = &quot;car&quot;
输出: false</code></pre><p><strong>说明：</strong></p>
<p>你可以假设字符串只包含小写字母。</p>
<p><strong>思路：</strong></p>
<p>是否是异位词，即每个字符串中字母出现的次数是否相同，因为只包含小写字母，所以我们用一个大小26的数组来存储出现的次数，如果字符更多可以用更大的数组或采用HashMap键值对存储字符和出现次数。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">        cnts[c - <span class="string">'a'</span>]++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t.toCharArray())&#123;</span><br><span class="line">        cnts[c - <span class="string">'a'</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnt : cnts)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>同构字符串</title>
    <url>/2019/12/03/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="Leetcode205-同构字符串"><a href="#Leetcode205-同构字符串" class="headerlink" title="Leetcode205.同构字符串"></a>Leetcode205.同构字符串</h1><p><strong>题目描述：</strong></p>
<p>给定两个字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: s = &quot;egg&quot;, t = &quot;add&quot;
输出: true</code></pre><hr>
<pre><code>输入: s = &quot;foo&quot;, t = &quot;bar&quot;
输出: false</code></pre><hr>
<pre><code>输入: s = &quot;paper&quot;, t = &quot;title&quot;
输出: true</code></pre><p><strong>思路：</strong></p>
<p>同构是指结构相同，也就是说两个字符串中的字符有着一一映射关系，对于映射关系我们很容易想到用哈希来解决，起初我是用HashMap存储它们的映射关系，有一点感觉不好的地方，例如我们以s的字符为键，当s的字符不在key中时，我们需要判断对应的t的字符是否在value中，这样的话要使用containsValue()，感觉效率不高。</p>
<p>然后我改用两个HashMap分别存储s和t的字符为键，值为它们上一次出现的位置，如果位置相同说明它们同构，然后出了一点问题，在代码里详细说一下。</p>
<p>最后采用的是把HashMap改为数组来保存，因为ASCII码只有256个，数组完全可以完成。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Character, Integer&gt; indexS = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; indexT = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(indexS.get(s.charAt(i)) != indexT.get(t.charAt(i))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        indexS.put(s.charAt(i), i);</span><br><span class="line">        indexT.put(t.charAt(i), i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是上面思路中的第二种方法，然后30个用例过了29个，起初我十分疑惑，测试了一下之后发现了问题，这个代码里有一个判断条件<code>indexS.get(s.charAt(i)) != indexT.get(t.charAt(i))</code>，返回值为Integer, 我们知道==和!=的判断比较的是内存地址，小于128时因为会自动转换为int，所以正常，当值为128时，不会拆箱，所以就出现了两个Integer对象值为128进行!=比较，这个会判断为真，因为它们是不同的对象，在堆中有着不同的存储地址。后续也进行了一些修改通过了，但是使得代码整洁性很差。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] indexS = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span>[] indexT = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(indexS[s.charAt(i)] != indexT[t.charAt(i)]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        indexS[s.charAt(i)] = i + <span class="number">1</span>;</span><br><span class="line">        indexT[t.charAt(i)] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后采用了数组方法完成，这里值得注意的一点就是赋值是i + 1，因为本身数组为0，所以应该用i + 1来保存位置。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转字符串里的单词</title>
    <url>/2019/12/03/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="Leetcode151-翻转字符串中的单词"><a href="#Leetcode151-翻转字符串中的单词" class="headerlink" title="Leetcode151.翻转字符串中的单词"></a>Leetcode151.翻转字符串中的单词</h1><p><strong>题目描述：</strong></p>
<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: &quot;the sky is blue&quot;
输出: &quot;blue is sky the&quot;</code></pre><hr>
<pre><code>输入: &quot;  hello world!  &quot;
输出: &quot;world! hello&quot;
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</code></pre><hr>
<pre><code>输入: &quot;a good   example&quot;
输出: &quot;example good a&quot;
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</code></pre><p><strong>说明：</strong></p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
<p><strong>思路：</strong></p>
<p>看到题有种做词法分析的感觉，但是相对来说简单很多，只需要分析空格，首先想到的是利用split()将字符串切分成单词，然后再让单词循环入栈出栈实现翻转，比较简单，下面利用的方法也差不多是一个道理，只是在分割的同时入栈，稍微快一点，因为做题嘛还是少用split()吧。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//尾部添加一个空格，保证最后一个单词正常存储</span></span><br><span class="line">    s += <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) != <span class="string">' '</span>)&#123;</span><br><span class="line">            temp.append(s.charAt(i));</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                stack.push(temp.toString());</span><br><span class="line">                temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">if</span>(!stack.isEmpty()) res.append(stack.pop());</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        res.append(<span class="string">" "</span>);</span><br><span class="line">        res.append(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>读HashMap源码的一些理解</title>
    <url>/2019/12/02/HashMap%E6%BA%90%E7%A0%81%E7%9A%84%E9%83%A8%E5%88%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<pre><code>也谈不上对HashMap做源码分析，网上的分析也很多，此篇博客记录自己学习HashMap的一些收获。</code></pre><h1 id="HashMap中做hash的方法"><a href="#HashMap中做hash的方法" class="headerlink" title="HashMap中做hash的方法"></a>HashMap中做hash的方法</h1><p>存储位置是<code>hash &amp; [n - 1]</code>，如果直接用HashCode()，高位不产生影响，键值对存放在哪里完全取决于低位，例如n = 16时取决于低四位，碰撞几率大。</p>
<p>因为hashCode()返回值为int32位，通过<code>hash ^ hash &gt;&gt;&gt; 16</code>，右移16位做异或，也就是高位为高16位，低位为高低16位进行异或的结果，那么低位就是由高位低位一起决定的，这样可以使散列更均匀，减少碰撞概率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="JDK1-8后加入了红黑树"><a href="#JDK1-8后加入了红黑树" class="headerlink" title="JDK1.8后加入了红黑树"></a>JDK1.8后加入了红黑树</h1><p><strong>原因</strong>：我们知道HashMap的平均查找复杂度是O(1)，当发生哈希碰撞时，会将键值对存在同一个桶下的一个链表里，因此当链表过长时，查找复杂度变为了O(n)，这就产生了性能问题，引入红黑树将复杂度变为O(logn)。</p>
<p><strong>转换条件</strong>：当链表长度 &gt;= <code>TREEIFY_THRESHOLD（8）</code>&amp;<code>tab.length &gt;= MIN_TREEIFY_CAPACITY（64）</code></p>
<p><strong>条件分析</strong>：</p>
<ul>
<li>为什么TREEIFY_THRESHOLD为8呢，根据官方的解释，根据概率某一个桶中元素超过8个的概率非常低，很有道理，毕竟我们不希望HashMap很轻易就进行转换红黑树的操作，那为什么UNTREEIFY_THRESHOLD定义为6呢，经过一些思考和查找，首先是链表它的优势在于插入删除效率高，不然我们全都用红黑树就好了，那么链表在长度为8时平均查找长度为4，长度为6时平均查找长度为3，红黑树在长度为8时平均查找长度为3，长度为6时平均查找长度为2.6，在长度小一点的时候查询效率差一点但影响不大，更应该考虑插入删除操作成本，所以UNTREEIFY_THRESHOLD为6，那为什么不是7，实际上7作为分水岭，如果等于8转换为红黑树，等于7又转换为链表，一些情况下会频繁进行红黑树-链表转换。</li>
<li>为什么第二个条件呢，因为当桶容量较小时，如果出现了长链表的情况，说明碰撞几率很高，此时我们应该进行扩容操作减少碰撞。容量小时，优先扩容可以避免一些列的不必要的树化过程。同时，桶容量较小时，扩容会比较频繁，扩容时需要拆分红黑树并重新映射。所以在桶容量比较小的情况下，将长链表转成红黑树是一件吃力不讨好的事。</li>
</ul>
<h1 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h1><p>HashMap中loadFactor的值为0.75，属于一种时间空间折中的策略。</p>
<p><code>过小</code>：使得碰撞更不容易发生，提高查找效率，但会浪费很多空间，例如我们将loadFactor设为0.5，每次桶占一半就会扩容一倍，当capacity为16时，桶为8发生扩容成32，然后桶为16扩容为64，我们会发现这个浪费的空间也是成倍增长，非常浪费空间。</p>
<p><code>过大</code>：虽然可以节省空间，但是更容易发生碰撞，降低效率，例如将loadFactor设为1，即桶不满就不会扩容，会出现大量链表，影响效率。</p>
<h1 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h1><p>在 HashMap 中，桶数组的长度均是2的幂，阈值大小为桶数组长度与负载因子的乘积。当 HashMap 中的键值对数量超过阈值时，进行扩容。</p>
<p>HashMap 的扩容机制与其他变长集合的套路不太一样，HashMap 按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍（如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去。</p>
<p>那么如何保证key的位置呢，根据HashMap的存储位置和扩容方法，我们可以发现，移动后的位置，要么在原位置，要么是在原位置再移动2次幂的位置。<br><img src="https://user-images.githubusercontent.com/45253106/69959234-9b40e380-1541-11ea-9e9c-9a70472e617e.png" alt></p>
<p><img src="https://user-images.githubusercontent.com/45253106/69959257-a8f66900-1541-11ea-8532-850a2c5f0221.png" alt></p>
<p>通过这两张图我们可以很清楚为什么，因为扩容是二倍，在做hash &amp; [n - 1]运算时刚好多了一位，为0则元素是原位置，为1则移动2次幂，同时也使得有50%几率保存在原位置，50%几率移动，使得扩容后元素比较均匀。</p>
<h1 id="桶数组table声明为transient"><a href="#桶数组table声明为transient" class="headerlink" title="桶数组table声明为transient"></a>桶数组table声明为transient</h1><p>java中声明为transient不会被默认的序列化机制序列化，起初了解到这个机制的时候很疑惑，因为桶数组是HashMap的底层数据结构，不被序列化的话如何传输和还原，后来了解到HashMap实现了两个方法来实现序列化，对键值对进行序列化，然后根据键值对可以重建HashMap数据。</p>
<p>之所以不对table进行序列化，主要是因为：</p>
<ul>
<li>table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间</li>
<li>同一个键值对在不同 JVM 下，所处的桶位置可能是不同的，在不同的 JVM 下反序列化 table 可能会发生错误。HashMap 的<code>get/put/remove</code>等方法第一步就是根据 hash 找到键所在的桶位置，但如果键没有覆写 hashCode 方法，计算 hash 时最终调用 Object 中的 hashCode 方法。但 Object 中的 hashCode 方法是 native 型的，不同的 JVM 下，可能会有不同的实现，产生的 hash 可能也是不一样的。也就是说同一个键在不同平台下可能会产生不同的 hash，此时再对在同一个 table 继续操作，就会出现问题。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>容器集合</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的三种遍历</title>
    <url>/2019/12/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<pre><code>二叉树的遍历是二叉树操作基础，这篇博客写一下自己对于二叉树遍历的非递归操作算法，因为递归操作很简单，所以
面试一般会问非递归的操作方法，重在考察对于三种遍历方式的理解和掌握程度。</code></pre><a id="more"></a>
<h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><blockquote>
<p>根-左-右</p>
</blockquote>
<pre><code>思路：用栈保存节点，访问一个节点后，先后将节点的右子树和左子树入栈，则下一个访问节点就是左子树节点，实际
上也变成了一种子操作，和递归类似，只是递归通过函数调用栈保存，我们手动用栈保存，迭代进行。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode p = stack.pop();</span><br><span class="line">        res.add(p.val);</span><br><span class="line">        <span class="keyword">if</span>(p.right != <span class="keyword">null</span>) stack.push(p.right);</span><br><span class="line">        <span class="keyword">if</span>(p.left != <span class="keyword">null</span>) stack.push(p.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><blockquote>
<p>左-根-右</p>
</blockquote>
<pre><code>思路：同样用栈保存，中序遍历要从左开始，因此循环判断是否有左子树并入栈，直到节点没有左子树，此时可以存储
该节点，并访问右子树，迭代操作。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><blockquote>
<p>左-右-根</p>
</blockquote>
<pre><code>思路：对于后序遍历，与前序遍历比较类似，因为左和右其实是类似的概念，所以对于后序遍历可以看做是前序遍历的
反向遍历，我们通过类似前序遍历的操作对树进行遍历，但是存储时将先存储的数据放在后面，或者在返回之前对
List进行逆序操作。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode cur = stack.pop();</span><br><span class="line">        res.addFirst(cur.val);</span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) stack.push(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) stack.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>思路二：前一种方法虽然看起来比较简单，但实际上是比较巧妙的办法，如果我们要按照后序遍历的概念方法进行操
作，如果有左子树还是循环左子树入栈，不同之处在于，当访问中间节点(根节点)时，如何判断此时是否访问过了它
的右子树，这里我们通过保存上一个遍历的TreeNode来进行判断，如果右子树未访问则先访问右子树，访问过则访
问中间节点。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode temp = stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="keyword">null</span> &amp;&amp; temp.right != last)&#123;</span><br><span class="line">                cur = temp.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(temp.val);</span><br><span class="line">                last = temp;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程基本概念</title>
    <url>/2019/11/18/111/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li>
<li>并发：OS的线程调度机制将时间划分为很多时间片段（时间片），尽可能均匀分配给正在运行的程序，获取CPU时间片的线程或进程得以被执行，其他则等待。通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。</li>
<li>线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果。</li>
<li>同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</li>
</ul>
<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p><img src="/2019/11/18/111/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt><br>各种状态一目了然，值得一提的是”blocked”这个状态：<br>线程在Running的过程中可能会遇到阻塞(Blocked)情况</p>
<ul>
<li>调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。</li>
<li>调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）</li>
<li>对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。</li>
<li>此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>用wait()/notify()实现生产者消费者问题</title>
    <url>/2019/11/18/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    <content><![CDATA[<p>转载自：<a href="https://limengting.site/2018/09/24/%E7%94%A8wait()notify()%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">limengting.site</a></p>
<p>这3个方法的作用：</p>
<p><code>wait</code>：线程自动释放其占有的对象锁，并等待notify</p>
<p><code>notify</code>：唤醒一个正在wait当前对象锁的线程，并让它拿到对象锁</p>
<p><code>notifyAll</code>：唤醒所有正在wait前对象锁的线程</p>
<a id="more"></a>

<p>notify和notifyAll的最主要的区别是：notify只是唤醒一个正在wait当前对象锁的线程，而notifyAll唤醒所有。值得注意的是：notify是本地方法，具体唤醒哪一个线程由虚拟机控制；notifyAll后并不是所有的线程都能马上往下执行，它们只是跳出了wait状态，接下来它们还会是竞争对象锁。</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>永远在synchronized的函数或对象里使用wait、notify和notifyAll，不然Java虚拟机会生成 IllegalMonitorStateException。</p>
</li>
<li><p>永远在while循环里而不是if语句下使用wait。这样，循环会在线程睡眠前后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知。</p>
</li>
<li><p>永远在多线程间共享的对象（在生产者消费者模型里即缓冲区队列）上使用wait。</p>
</li>
<li><p>notify 仅仅通知一个线程，并且我们不知道哪个线程会收到通知，然而 notifyAll 会通知所有等待中的线程。换言之，如果只有一个线程在等待一个信号灯，notify和notifyAll都会通知到这个线程。但如果多个线程在等待这个信号灯，那么notify只会通知到其中一个，而其它线程并不会收到任何通知，而notifyAll会唤醒所有等待中的线程。所以更倾向用 notifyAll()，而不是 notify()。</p>
</li>
<li><p>调用wait()/notify()都是在synchronized代码块中，已经拿到对象锁。A线程调用wait()之后A线程释放锁，A线程进入等待状态；B线程调用notify()之后唤醒一个正在wait对象锁的线程，只有A在等待就唤醒A，B不会马上释放锁，要到synchronized代码块退出之后才释放锁。</p>
</li>
</ul>
<p>我们有两个线程，分别名为PRODUCER（生产者）和CONSUMER（消费者），他们分别继承了Producer和Consumer类，而Producer和Consumer都继承了Thread类。Producer和Consumer想要实现的代码逻辑都在run()函数内。Main线程开始了生产者和消费者线程，并声明了一个LinkedList作为缓冲区队列（在Java中，LinkedList实现了队列的接口）。生产者在无限循环中持续往LinkedList里插入随机整数直到LinkedList满。我们在while(queue.size == maxSize)循环语句中检查这个条件。请注意到我们在做这个检查条件之前已经在队列对象上使用了synchronized关键词，因而其它线程不能在我们检查条件时改变这个队列。如果队列满了，那么PRODUCER线程会在CONSUMER线程消耗掉队列里的任意一个整数，并用notify来通知PRODUCER线程之前持续等待。在我们的例子中，wait和notify都是使用在同一个共享对象上的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生产者消费者的缓冲区</span></span><br><span class="line">        Queue&lt;Integer&gt; buffer = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">10</span>;</span><br><span class="line">        Thread producer1 = <span class="keyword">new</span> Producer(buffer, maxSize, <span class="string">"producer1"</span>);</span><br><span class="line">        Thread producer2 = <span class="keyword">new</span> Producer(buffer, maxSize, <span class="string">"producer2"</span>);</span><br><span class="line">        Thread consumer1 = <span class="keyword">new</span> Consumer(buffer, <span class="string">"consumer1"</span>);</span><br><span class="line">        Thread consumer2 = <span class="keyword">new</span> Consumer(buffer, <span class="string">"consumer2"</span>);</span><br><span class="line">        producer1.start();</span><br><span class="line">        producer2.start();</span><br><span class="line">        consumer1.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; buffer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Queue&lt;Integer&gt; buffer, <span class="keyword">int</span> maxSize, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一直会尝试去抢buffer的对象锁</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (buffer) &#123;</span><br><span class="line">                <span class="comment">// 进入了synchronized代码区则表明已经抢到了锁</span></span><br><span class="line">                <span class="comment">// 缓冲区为满，放不下</span></span><br><span class="line">                <span class="keyword">while</span> (buffer.size() == maxSize) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"Buffer is full, cannot produce!"</span>);</span><br><span class="line">                    <span class="comment">// 生产者释放锁，等待被notify</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        buffer.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 随便生产一个10以内的数放入缓冲区</span></span><br><span class="line">                <span class="keyword">int</span> tmp = random.nextInt(<span class="number">10</span>);</span><br><span class="line">                buffer.add(tmp);</span><br><span class="line">                System.out.print(<span class="keyword">this</span>.getName() + <span class="string">" produces value : "</span> + tmp + <span class="string">", size of buffer = "</span> + buffer.size() + <span class="string">", buffer = "</span>);</span><br><span class="line">                <span class="keyword">for</span> (Integer i : buffer) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="comment">// 唤醒在wait的线程，准备释放buffer对象锁</span></span><br><span class="line">                buffer.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; buffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Queue&lt;Integer&gt; buffer, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一直尝试去抢buffer的对象锁</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (buffer) &#123;</span><br><span class="line">                <span class="comment">// 进入了synchronized代码区则表明已经抢到了锁</span></span><br><span class="line">                <span class="keyword">while</span> (buffer.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"Buffer is empty, cannot consume!"</span>);</span><br><span class="line">                    <span class="comment">// 消费者线程被阻塞，释放锁</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        buffer.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从末端消费一个</span></span><br><span class="line">                System.out.print(<span class="keyword">this</span>.getName() + <span class="string">" consumes value : "</span> + buffer.remove() + <span class="string">", size of buffer = "</span> + buffer.size() + <span class="string">", buffer = "</span>);</span><br><span class="line">                <span class="keyword">for</span> (Integer i : buffer) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="comment">// notify在wait的被阻塞的线程，准备释放buffer对象锁</span></span><br><span class="line">                buffer.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始做项目-图书管理</title>
    <url>/2019/11/16/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%81%9A%E9%A1%B9%E7%9B%AE-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<pre><code>这篇博客记录一下自己做一个Demo项目的全过程，写博客一方面督促自己，一方面可以让自己更熟悉流程和细节，项目
资料是从Nowcoder上找的，项目的前端文件是直接使用了源项目文件，后端自己写了一遍。</code></pre><a id="more"></a>
<h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><h2 id="工程简介"><a href="#工程简介" class="headerlink" title="工程简介"></a>工程简介</h2><pre><code>项目利用Maven，利用SpringBoot作为项目主体框架（SpringBoot相比整合SSM少了很多配置，可以把精力放在代码
开发和业务逻辑上，其本质还是SSM），项目使用Freemaker、Web、MyBatis、Aspect四个模块。</code></pre><h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><pre><code>项目实现图书管理，主要包含注册、登录、向书库中添加书目、借书、还书等操作，通过MD5加密算法对用户密码进
行加密，通过cookie与ticket进行登录权限验证。</code></pre><h1 id="项目流程"><a href="#项目流程" class="headerlink" title="项目流程"></a>项目流程</h1><h2 id="项目创建方式"><a href="#项目创建方式" class="headerlink" title="项目创建方式"></a>项目创建方式</h2><ul>
<li>在<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> 挑选模块之后下载到本地，用IDE打开</li>
<li>在IDE中创建项目，我使用的是IDEA，选择Spring initializr，挑选模块后完成创建<h2 id="项目文件夹"><a href="#项目文件夹" class="headerlink" title="项目文件夹"></a>项目文件夹</h2></li>
<li>biz 业务逻辑层，用来存放比较复杂的逻辑</li>
<li>configuration 用来放Spring Boot的代码配置</li>
<li>controllers 控制层，控制器都在这里，也可以认为是网页的入口都在这</li>
<li>dao 持久层，跟数据库交互的包，主要是MyBatis在这里编码</li>
<li>interceptor AOP的代码都在这</li>
<li>model 各种数据模型，对数据的描述</li>
<li>service 一般用作对dao层的封装</li>
<li>utils 工具包，一般都是静态方法。</li>
</ul>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> bookmanager</span><br></pre></td></tr></table></figure>
<pre><code>分别创建三张表user、book、ticket，可以先向book表中插入几条数据</code></pre><h2 id="完成图书的CRUD"><a href="#完成图书的CRUD" class="headerlink" title="完成图书的CRUD"></a>完成图书的CRUD</h2><h3 id="创建图书实体类Book-java"><a href="#创建图书实体类Book-java" class="headerlink" title="创建图书实体类Book.java"></a>创建图书实体类Book.java</h3><pre><code>描述图书的基本属性，对应数据库表，写入Getter和Setter方法</code></pre><h3 id="创建图书的DAO层BookDAO-java"><a href="#创建图书的DAO层BookDAO-java" class="headerlink" title="创建图书的DAO层BookDAO.java"></a>创建图书的DAO层BookDAO.java</h3><pre><code>DAO层就是利用具体SQL实现CRUD，也是常说的Mapper，因为项目是Mybatis作为持久层框架的，所以可以选择写相应
Xml完成映射，或直接用注解，本项目采用的是注解方法（个人感觉能用注解的时候都用注解，很清晰）</code></pre><h3 id="创建BookService-java"><a href="#创建BookService-java" class="headerlink" title="创建BookService.java"></a>创建BookService.java</h3><pre><code>这里的Service层就是对Controller层和Model层的解耦，通用的业务逻辑实现应该在Service层中，如果去掉这一层
其实也可以运行，我们直接在Controller层中实现业务逻辑，并直接调用持久层(也就是DAO层)实现数据库操作，也
可以完成相应内容，但代码的耦合度就变得很高。在本项目中主要是对DAO进行封装。</code></pre><h3 id="创建BookController-java"><a href="#创建BookController-java" class="headerlink" title="创建BookController.java"></a>创建BookController.java</h3><pre><code>Controller也就是MVC中的C，这时候的Controller还不完整，只是先出一个运行效果，可以访问主页，代码也只有
下面几行。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/index"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bookList</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        loadAllBooksView(model);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"book/books"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadAllBooksView</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"books"</span>, bookService.getAllBooks());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="看到运行效果"><a href="#看到运行效果" class="headerlink" title="看到运行效果"></a>看到运行效果</h3><pre><code>访问127.0.0.1:8080/index也就是主页的URL</code></pre><p><img src="/2019/11/16/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%81%9A%E9%A1%B9%E7%9B%AE-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%90%E8%A1%8C.png" alt><br>(其实和写了一个HelloWorld没什么太大区别哈哈哈哈，第一个流程也属于先让项目运行起来，熟悉一下流程)</p>
<h2 id="完成User类和Ticket类"><a href="#完成User类和Ticket类" class="headerlink" title="完成User类和Ticket类"></a>完成User类和Ticket类</h2><h3 id="创建User-java和Ticket-java"><a href="#创建User-java和Ticket-java" class="headerlink" title="创建User.java和Ticket.java"></a>创建User.java和Ticket.java</h3><pre><code>写对应实体类</code></pre><h3 id="创建UserDAO-java和TicketDAO-java"><a href="#创建UserDAO-java和TicketDAO-java" class="headerlink" title="创建UserDAO.java和TicketDAO.java"></a>创建UserDAO.java和TicketDAO.java</h3><pre><code>完成DAO层的CRUD</code></pre><h3 id="创建UserService-java和TicketService-java"><a href="#创建UserService-java和TicketService-java" class="headerlink" title="创建UserService.java和TicketService.java"></a>创建UserService.java和TicketService.java</h3><pre><code>根据需求对DAO层进行封装</code></pre><h2 id="完成工具类"><a href="#完成工具类" class="headerlink" title="完成工具类"></a>完成工具类</h2><pre><code>这部分跟着源项目学习了一下，下面贴一下源项目的介绍。</code></pre><p><strong>MD5.java</strong></p>
<p>这个类就是用来加密的。服务器不保存用户的明文密码是一项基本常识，所以我们用MD5来加密。这里也不要专注于MD5的具体实现方法，这不是我们的主要任务，但建议你至少要知道MD5常用在什么地方，并知道这个加密是不可逆的就可以了。</p>
<p><strong>UuidUtils.java</strong></p>
<p>注意到Cookie都是一串无意义的码串，我们用JDK自带的UUID生成器可以非常方便的生成这样一串随机的字符串。</p>
<p><strong>ConcurrentUtils.java</strong></p>
<p>用来保存当前访问者的容器。我们知道，当web程序运行在web服务器中时，都是并发的<br>环境，拿tomcat来说，对于每一个请求tomcat都会从自己维护的线程池中选一个线程去处理这个请求。ThreadLocal这个类提供了一种线程id到一个泛型的绑定，你可以认为它是一个Map，当我们从里面取数据的时候，实际上是将当前的线程id作为map的key，取出之前这个线程存的东西。这里我们将User保存在里面，这样我们就能随时在程序的任何地方拿出User信息了。</p>
<p><strong>CookieUtils.java</strong></p>
<p>用来封装http请求中的Cookie的操作。</p>
<p><strong>TicketUtils.java</strong></p>
<p>提供了一个生产Ticket的方法。</p>
<p><strong>LoginRegisterException.java</strong></p>
<p>封装的Exception类，用来抛出异常信息。</p>
<p><strong>HostHolder.java</strong></p>
<p>HostHolder是一个重要的类，用来包装ConcurrentUtils.java的方法，并交给Spring容器去管理，使得我们可以在任何时候都能找当前的User，只要用户登录了，我们就将User信息设置到HostHolder里面，这样我们就在其他地方可以直接拿出User来用。</p>
<h2 id="完成登录注册逻辑LoginBiz-java"><a href="#完成登录注册逻辑LoginBiz-java" class="headerlink" title="完成登录注册逻辑LoginBiz.java"></a>完成登录注册逻辑LoginBiz.java</h2><pre><code>biz是business的简写，用来保存较为复杂的业务逻辑，其本身也是一个service，一般命名Service的用来对DAO层进行封装，命名Biz表示复杂业务逻辑。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginBiz</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TicketService ticketService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录逻辑，LoginController调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> email</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> T票的Ticket(String)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String email, String password)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        User user = userService.getUser(email);</span><br><span class="line">        <span class="comment">//验证是否可以登录</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LoginRegisterException(<span class="string">"账户不存在，请重新输入或注册账号"</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.equals(MD5.next(password), user.getPassword()))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LoginRegisterException(<span class="string">"密码不正确"</span>);</span><br><span class="line">        <span class="comment">//检查Ticket</span></span><br><span class="line">        Ticket t = ticketService.getTicket(user.getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;</span><br><span class="line">            t = TicketUtils.next(user.getId());</span><br><span class="line">            ticketService.addTicket(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t.getExpiredAt().before(<span class="keyword">new</span> Date()))&#123;</span><br><span class="line">            ticketService.deleteTicket(t.getId());</span><br><span class="line">            t = TicketUtils.next(user.getId());</span><br><span class="line">            ticketService.addTicket(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ConcurrentUtils.setHost(user);</span><br><span class="line">        <span class="keyword">return</span> t.getTicket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登出逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(String t)</span></span>&#123;</span><br><span class="line">        ticketService.deleteTicket(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> LoginRegisterException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(User user)</span> <span class="keyword">throws</span> LoginRegisterException</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(userService.getUser(user.getEmail()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LoginRegisterException(<span class="string">"用户账号已存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        user.setPassword(MD5.next(user.getPassword()));</span><br><span class="line">        userService.addUser(user);</span><br><span class="line"></span><br><span class="line">        Ticket t = TicketUtils.next(user.getId());</span><br><span class="line">        ticketService.addTicket(t);</span><br><span class="line"></span><br><span class="line">        ConcurrentUtils.setHost(user);</span><br><span class="line">        <span class="keyword">return</span> t.getTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完成控制层Controller"><a href="#完成控制层Controller" class="headerlink" title="完成控制层Controller"></a>完成控制层Controller</h2><h3 id="完成HomeController"><a href="#完成HomeController" class="headerlink" title="完成HomeController"></a>完成HomeController</h3><pre><code>这个是我自己新加的，之前index也就是主页也放在了BookController里，个人感觉不是很合适，分离出来以后BookController只注入BookService，降低耦合度。</code></pre><h3 id="完成BookController"><a href="#完成BookController" class="headerlink" title="完成BookController"></a>完成BookController</h3><pre><code>将借书、还书实现，简单调用BOOKService方法即可。</code></pre><h3 id="完成LoginController"><a href="#完成LoginController" class="headerlink" title="完成LoginController"></a>完成LoginController</h3><pre><code>主要调用LoginBiz方法。</code></pre><h2 id="实现拦截器完成登录权限验证"><a href="#实现拦截器完成登录权限验证" class="headerlink" title="实现拦截器完成登录权限验证"></a>实现拦截器完成登录权限验证</h2><pre><code>两个拦截器一个用来注入host信息，另一个用来进行权限验证。</code></pre><h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><pre><code>此项目基本就是拿来熟悉一下一个SpringBoot项目从零到运行，不得不说真的比SSM项目轻松许多，SSM项目要配置web.xml，spring的xml，springMVC的xml。
项目中也有一些bug，例如退出登录后仍显示登录名，在注册时分配的ticket无效，直到登陆重新创建(虽然没太大影响，但是会多出来一个userid为0的ticket)，自己写的时候也改了一下，在完成项目时仍有问题，不过不属于编码问题，从项目设计就有的问题，例如应该有张表来维护用户和书的借还关系，此项目里A用户借走了书1，B用户点击归还书1也会成功归还，因为是通过book表的status列维护的，本来想在代码里增加一些判断来确保只有借走书的人才可以还，但是直接改的话会增加不少耦合性，代码也会看起来很乱，从设计阶段改的话工作量也很小(还是懒得改，主要还是为了练手)</code></pre><h1 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h1><pre><code>https://github.com/zealyoung/SpringBoot-BookManager</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>实战小项目</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划-最大M段子段和</title>
    <url>/2019/11/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E5%A4%A7M%E6%AE%B5%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h2><pre><code>给定由n个整数（可能为负）组成的序列a1、a2、a3...,an,以及一个正整数m，要求确定序列的m个不相交子段，使这m个子段的总和最大！
特别注意：
有些题目可能不存在负数答案，给出的序列全是负数，那么不管m是多少，答案是0。此时选择的子段是0个，不足m个，但符合题意。
也可能有些题目要求，必须选够m个子段。区别在dp数组的初始化。前者要求dp初始为0，后者要求第0行为0，其余为负无穷</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><pre><code>与最大子段和类似，对于最大子段和我们常用分治算法和动态规划求解，对于最大M段子段和也类似，利用二维数组dp，dp[ i ][ j ]，表示前 j 项所构成 i 子段的最大和，且必须包含着第j项，即以第j项结尾.
求dp[ i ][ j ]，有两种情况：

1、dp[ i ][ j ] = dp[ i ] [ j-1 ] + a[ j ] ，即把第j项融合到第 j-1 项的子段中，子段数不变

2、dp[ i ][ j ] = dp[ i-1 ] [ t ] + a[ j ]，（i-1&lt;= t &lt; j ）把第 j 项作为单独的一个子段，然后找一下i-1个子段时，最大的和，然后加上a[ j ] </code></pre>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中的注解</title>
    <url>/2019/11/12/Spring%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>@Controller</strong></p>
<pre><code>标识一个该类是Spring MVC controller处理器，用来创建处理http请求的对象.</code></pre><p><strong>@RestController</strong></p>
<pre><code>Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。</code></pre><p><strong>@Service</strong></p>
<pre><code>用于标注业务层组件，就是加入你有一个用注解的方式把这个类注入到spring配置中。</code></pre><p><strong>@Autowired</strong></p>
<pre><code>用来装配bean，都可以写在字段上，或者方法上。默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired(required=false)。</code></pre><p><strong>@RequestMapping</strong></p>
<pre><code>@RequestMapping 注解可以在控制器类的级别和/或其中的方法的级别上使用。@RequestMapping的用法非常多，可以参考&lt;https://blog.csdn.net/weinichendian/article/details/84247036&gt;</code></pre><p><strong>@RequestParam</strong></p>
<pre><code>用于将请求参数区数据映射到功能处理方法的参数上。</code></pre><p><strong>@ModelAttribute</strong></p>
<pre><code>参考&lt;https://blog.csdn.net/abc997995674/article/details/80464023&gt;</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>经典回溯-N皇后问题</title>
    <url>/2019/11/11/%E7%BB%8F%E5%85%B8%E5%9B%9E%E6%BA%AF-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Leetcode51-N皇后问题"><a href="#Leetcode51-N皇后问题" class="headerlink" title="Leetcode51.N皇后问题"></a>Leetcode51.N皇后问题</h1><p><strong>题目描述</strong>：</p>
<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。<br><img src="/2019/11/11/%E7%BB%8F%E5%85%B8%E5%9B%9E%E6%BA%AF-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/8-queens.png" alt></p>
<a id="more"></a>
<p><strong>示例</strong>：</p>
<pre><code>输入: 4
输出: [
[&quot;.Q..&quot;,  // 解法 1
&quot;...Q&quot;,
&quot;Q...&quot;,
&quot;..Q.&quot;],

[&quot;..Q.&quot;,  // 解法 2
&quot;Q...&quot;,
&quot;...Q&quot;,
&quot;.Q..&quot;]
]
解释: 4 皇后问题存在两个不同的解法。</code></pre><p><strong>思路</strong>：</p>
<p>N皇后问题是一道经典的回溯问题，回溯本质上也是一种搜索算法，在搜索过程中进行”剪枝” + “状态重置”，对于本题来说，例如我们将第二个皇后放在某一个位置不满足条件时，就不需要再去排列其他的皇后，而是直接回溯到放置第二个皇后的前一个状态，并尝试下一个位置，判断是回溯算法后就是如何剪枝让搜索更快，对于此题来说，每行一个皇后，根据不能相互攻击的条件，皇后不能出现在同一列，同一对角线(主、副)，我们利用三个哈希表来存储三个条件。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            nums[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; col = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; master = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; slave = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        backtrack(nums, <span class="number">0</span>, n, col, master, slave, s, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> row, <span class="keyword">int</span> n, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    Set&lt;Integer&gt; col,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Set&lt;Integer&gt; master,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Set&lt;Integer&gt; slave,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Stack&lt;Integer&gt; s,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    List&lt;List&lt;String&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            res.add(makelist(s, n));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!col.contains(i) &amp;&amp; !master.contains(row - i) &amp;&amp;   </span><br><span class="line">                                    !slave.contains(row + i))&#123;</span><br><span class="line">                s.push(nums[i]);</span><br><span class="line">                col.add(i);</span><br><span class="line">                master.add(row - i);</span><br><span class="line">                slave.add(row + i);</span><br><span class="line"></span><br><span class="line">                backtrack(nums, row + <span class="number">1</span>, n, col, master, slave, s, res);</span><br><span class="line"></span><br><span class="line">                slave.remove(row + i);</span><br><span class="line">                master.remove(row - i);</span><br><span class="line">                col.remove(i);</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">makelist</span><span class="params">(Stack&lt;Integer&gt; s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Integer num : s)&#123;</span><br><span class="line">            StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt; n; i++)&#123;</span><br><span class="line">                str.append(<span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            str.replace(num, num + <span class="number">1</span>, <span class="string">"Q"</span>);</span><br><span class="line">            ans.add(str.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>回溯法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2019/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="/2019/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/code12.jpg" alt></p>
<a id="more"></a>
<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p>思路：共N-1趟排序，从p = 0到N-1的位置，保证从位置0到位置p的元素有序，将下一个元素插入有序序列形成新的有序序列。</p>
<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<p>是否稳定：稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j, tmp;</span><br><span class="line">        tmp = array[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i; j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; array[j - <span class="number">1</span>]; j--)&#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        array[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>思路：选取一个增量序列共k个，进行k趟排序，每次排序根据增量分成子序列，利用插入排序对子序列进行排序，最后一个增量为1，整个序列进行排序。</p>
<p>时间复杂度：O(n^1.3-2)</p>
<p>空间复杂度：O(1)</p>
<p>是否稳定：不稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> gap = array.length; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j, tmp;</span><br><span class="line">            tmp = array[i];</span><br><span class="line">            <span class="keyword">for</span>(j = i; j &gt;= gap &amp;&amp; tmp &lt; array[j - gap]; j -= gap)&#123;</span><br><span class="line">                array[j] = array[j - gap];</span><br><span class="line">            &#125;</span><br><span class="line">            array[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>思路：循环遍历，每次循环通过两两比较确定一个最大或最小值。</p>
<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<p>是否稳定：稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="comment">//当一次循环没有更改元素位置时，说明数组有序，直接退出</span></span><br><span class="line">        <span class="keyword">boolean</span> canBreak = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                canBreak = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(canBreak) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>思路：选取枢纽元，左右同时移动，将小于枢纽元的放在枢纽元前面，大于枢纽元的放在枢纽元后面，进行递归直到完全有序。</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(logn)</p>
<p>是否稳定：不稳定</p>
<p>tips:</p>
<ul>
<li><p>一般选取第一个元素作为枢纽元，更好的做法是采用三数中值分割法。</p>
</li>
<li><p>由于是递归操作，当数组被分割的很小时采用插入排序更快，一般是5-20。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = partition(array, left, right);</span><br><span class="line">        quickSort(array, left, index - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, index + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = array[left];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; array[right] &gt;= pivot) right--;</span><br><span class="line">        array[left] = array[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; array[left] &lt;= pivot) left++;</span><br><span class="line">        array[right] = array[left];</span><br><span class="line">    &#125;</span><br><span class="line">    array[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><p>思路：在未排序序列中查找出最小(大)元素，放入排序序列起始位置，继续在剩下未排序序列中重复查找，直到完全有序。</p>
<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<p>是否稳定：不稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; array.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &lt; array[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != min)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = array[i];</span><br><span class="line">            array[i] = array[min];</span><br><span class="line">            array[min] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>思路：根据堆的性质，每次用O(1)时间从堆顶获取数组最大值，并将其放在数组最末尾，并重新下滤形成一个Max堆，直到完全有序。</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<p>是否稳定：不稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="comment">//BuildMaxHeap</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = array.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        percDown(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DeleteMax</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        swap(array, <span class="number">0</span> ,i);</span><br><span class="line">        percDown(array, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">percDown</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(tmp = array[i]; <span class="number">2</span> * i + <span class="number">1</span> &lt; n; i = child)&#123;</span><br><span class="line">        child = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(child != n - <span class="number">1</span> &amp;&amp; array[child] &lt; array[child + <span class="number">1</span>])&#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[child] &gt; tmp)&#123;</span><br><span class="line">            array[i] = array[child];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = array[m];</span><br><span class="line">    array[m] = array[n];</span><br><span class="line">    array[n] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>思路：归并排序采用分治算法，每次将序列分对半分，分别对两个序列进行排序，将两个有序序列合成一个完全有序序列。</p>
<p>时间复杂度：O(nlogn);</p>
<p>空间复杂度：O(n);</p>
<p>是否稳定：稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    mergeSort(array, tmp, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] tmp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right - left &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(array, tmp, left, mid);</span><br><span class="line">    mergeSort(array, tmp, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(array, tmp, left, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] tmp, <span class="keyword">int</span> leftPos, <span class="keyword">int</span> rightPos, <span class="keyword">int</span> rightEnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftEnd = rightPos - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmpPos = leftPos;</span><br><span class="line">    <span class="keyword">int</span> nums = rightEnd - leftPos + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[leftPos] &lt;= array[rightPos])&#123;</span><br><span class="line">            tmp[tmpPos++] = array[leftPos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[tmpPos++] = array[rightPos++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(leftPos &lt;= leftEnd)&#123;</span><br><span class="line">        tmp[tmpPos++] = array[leftPos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(rightPos &lt;= rightEnd)&#123;</span><br><span class="line">        tmp[tmpPos++] = array[rightPos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++, rightEnd--)&#123;</span><br><span class="line">        array[rightEnd] = tmp[rightEnd];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
</search>
