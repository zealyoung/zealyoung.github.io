<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>生产机器数量</title>
    <url>/2020/02/16/%E7%94%9F%E4%BA%A7%E6%9C%BA%E5%99%A8%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p><strong>题目描述：</strong></p>
<p>一台新机器，第4年可以生产一台机器，以后每一年生产1台。 生产出来的新机器第4年又可以生产一台机器，后续每年可以生产1台。</p>
<p>现在有一台新机器，求第n年总共有多少台机器。 计算结果对109+7取模。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：10</span><br><span class="line">输出：19</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：15</span><br><span class="line">输出：129</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<p>每台新机器都会在第四年生产，此后每年生产，那么第n年新增多少呢？显然是n-3年时有多少机器，这些机器在第n年都会有新增机器。</p>
<p>则machine[n] = machine[n-1] + machine[n - 3]。也就是说第n年只需求出n-1和n-3年。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">machineNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (queue.getFirst() + queue.getLast()) % <span class="number">1000000007</span>;</span><br><span class="line">        queue.add(num);</span><br><span class="line">        queue.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> queue.getLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2020/02/16/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</p>
<h2 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h2><p><img src="https://user-images.githubusercontent.com/45253106/74599611-db831d00-50bf-11ea-8155-5f833b73b64b.png" alt="image"></p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Prototype <span class="title">myClone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype</span><span class="params">(String filed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filed = filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Prototype <span class="title">myClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcretePrototype(filed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Prototype prototype = <span class="keyword">new</span> ConcretePrototype(<span class="string">"abc"</span>);</span><br><span class="line">        Prototype clone = prototype.myClone();</span><br><span class="line">        System.out.println(clone.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2020/02/14/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</p>
<h2 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h2><ul>
<li>Originator：原始对象</li>
<li>Caretaker：负责保存好备忘录</li>
<li>Memento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。</li>
</ul>
<p>![image-20200214212853630](/Users/zealyoung/Library/Application Support/typora-user-images/image-20200214212853630.png)</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameRole</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> attack = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vitality = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> defense = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//战斗，数值下降</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attack -= <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">this</span>.vitality -= <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">this</span>.defense -= <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//保存当前状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoleStateMemento <span class="title">saveState</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> RoleStateMemento(attack, vitality, defense));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//状态回退，恢复到保存时状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoveryState</span><span class="params">(RoleStateMemento memento)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attack = memento.getAttack();</span><br><span class="line">        <span class="keyword">this</span>.vitality = memento.getVitality();</span><br><span class="line">        <span class="keyword">this</span>.defense = memento.getDefense();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//省略Get、Set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"GameRole&#123;"</span> +</span><br><span class="line">                <span class="string">"attack="</span> + attack +</span><br><span class="line">                <span class="string">", vitality="</span> + vitality +</span><br><span class="line">                <span class="string">", defense="</span> + defense +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateDisplay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">角色状态备忘录</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoleStateMemento</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> attack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vitality;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> defense;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoleStateMemento</span><span class="params">(<span class="keyword">int</span> attack, <span class="keyword">int</span> vitality, <span class="keyword">int</span> defense)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attack = attack;</span><br><span class="line">        <span class="keyword">this</span>.vitality = vitality;</span><br><span class="line">        <span class="keyword">this</span>.defense = defense;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略Get、Set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">角色状态管理者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoleStateCaretaker</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RoleStateMemento memento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoleStateMemento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(RoleStateMemento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">客户端代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GameRole asura = <span class="keyword">new</span> GameRole();</span><br><span class="line"></span><br><span class="line">        RoleStateCaretaker caretaker = <span class="keyword">new</span> RoleStateCaretaker();</span><br><span class="line">        caretaker.setMemento(asura.saveState());</span><br><span class="line">		</span><br><span class="line">        asura.stateDisplay();</span><br><span class="line">        </span><br><span class="line">        asura.fight();</span><br><span class="line">        asura.stateDisplay();</span><br><span class="line"></span><br><span class="line">        asura.recoveryState(caretaker.getMemento());</span><br><span class="line">        asura.stateDisplay();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>GameRole{attack=100, vitality=100, defense=100}<br>GameRole{attack=50, vitality=50, defense=50}<br>GameRole{attack=100, vitality=100, defense=100}</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/2020/02/05/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="剑指Offer-顺时针打印矩阵"><a href="#剑指Offer-顺时针打印矩阵" class="headerlink" title="剑指Offer.顺时针打印矩阵"></a>剑指Offer.顺时针打印矩阵</h1><p><strong>题目描述：</strong></p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1  2  3  4</span><br><span class="line">	 5  6  7  8</span><br><span class="line">	 9  10 11 12</span><br><span class="line">	 13 14 15 16</span><br><span class="line">输出：[1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<p>因为是顺时针输出，我们将数组进行逆序旋转的话，就可以一直输出第一行，例如对于示例输出[1,2,3,4]然后对其余进行逆时针旋转，第一行的[8,12,16]就是接下来要输出的内容，直到数组全部输出,这种方法稍微复杂，数组要进行多次旋转。</p>
<p>可以按照顺时针输出的特点，按照下标循环输出，这种方法比较简单，采用这种方法写一下代码。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> r1 = <span class="number">0</span>, r2 = matrix.length - <span class="number">1</span>, c1 = <span class="number">0</span>, c2 = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(r1 &lt;= r2 &amp;&amp; c1 &lt;= c2)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = c1; i &lt;= c2; i++)&#123;</span><br><span class="line">            ret.add(matrix[r1][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r1 + <span class="number">1</span>; i &lt;= r2; i++)&#123;</span><br><span class="line">            ret.add(matrix[i][c2]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = c2 - <span class="number">1</span>; i &gt;= c1 &amp;&amp; r1 != r2; i--)&#123;</span><br><span class="line">            ret.add(matrix[r2][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r2 - <span class="number">1</span>; i &gt; r1 &amp;&amp; c1 != c2; i--)&#123;</span><br><span class="line">            ret.add(matrix[i][c1]);</span><br><span class="line">        &#125;</span><br><span class="line">        r1++;r2--;c1++;c2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算问题</title>
    <url>/2020/01/28/%E4%BD%8D%E8%BF%90%E7%AE%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>本文总结一下位运算常用的方法和一些题目的解法。</p>
</blockquote>
<p><strong>基本原理</strong></p>
<p>0s 表示一串 0，1s 表示一串 1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x ^ 0s = x      x &amp; 0s = 0      x | 0s = x</span><br><span class="line">x ^ 1s = ~x     x &amp; 1s = x      x | 1s = 1s</span><br><span class="line">x ^ x = 0       x &amp; x = x       x | x = x</span><br></pre></td></tr></table></figure>

<ul>
<li>利用 x ^ 1s = ~x 的特点，可以将位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。</li>
<li>利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。</li>
<li>利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。</li>
</ul>
<p>位与运算技巧：</p>
<ul>
<li>n&amp;(n-1) 去除 n 的位级表示中最低的那一位。例如对于二进制表示 10110100，减去 1 得到 10110011，这两个数相与得到 10110000。</li>
<li>n&amp;(-n) 得到 n 的位级表示中最低的那一位。-n 得到 n 的反码加 1，对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。</li>
<li>n-n&amp;(~n+1) 去除 n 的位级表示中最高的那一位。</li>
</ul>
<p>移位运算：</p>
<ul>
<li>&gt;&gt; n 为算术右移，相当于除以 2n；</li>
<li>&gt;&gt;&gt; n 为无符号右移，左边会补上 0。</li>
<li>&lt;&lt; n 为算术左移，相当于乘以 2n。</li>
</ul>
<p><strong>mask 计算</strong></p>
<p>要获取 111111111，将 0 取反即可，~0。</p>
<p>要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1&lt;&lt;(i-1) 。例如 1&lt;&lt;4 得到只有第 5 位为 1 的 mask ：00010000。</p>
<p>要得到 1 到 i 位为 1 的 mask，(1&lt;&lt;i)-1 即可，例如将 (1&lt;&lt;4)-1 = 00010000-1 = 00001111。</p>
<p>要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1&lt;&lt;i)-1)。</p>
<p><strong>Java 中的位操作</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int Integer.bitCount();           // 统计 1 的数量</span><br><span class="line">static int Integer.highestOneBit();      // 获得最高位</span><br><span class="line">static String toBinaryString(int i);     // 转换为二进制表示的字符串</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode461-汉明距离"><a href="#Leetcode461-汉明距离" class="headerlink" title="Leetcode461.汉明距离"></a>Leetcode461.汉明距离</h1><p><a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">Leetcode461.汉明距离</a></p>
<blockquote>
<p>两个整数之间的<a href="https://baike.baidu.com/item/汉明距离" target="_blank" rel="noopener">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目，异或操作进行计算。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(z != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((z &amp; <span class="number">1</span>) == <span class="number">1</span>) cnt++;</span><br><span class="line">        z = z &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//z &amp;= (z - 1);</span></span><br><span class="line">        <span class="comment">//cnt++;</span></span><br><span class="line">        <span class="comment">//注释代码可用于替换上面2行，不同方式。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Integer.bitCount()用于统计1的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.bitCount(x ^ y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode268-缺失数字"><a href="#Leetcode268-缺失数字" class="headerlink" title="Leetcode268.缺失数字"></a>Leetcode268.缺失数字</h1><p><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener">Leetcode268.缺失数字</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        ret ^= nums[i] ^ i;</span><br><span class="line">    &#125;</span><br><span class="line">    ret ^= nums.length;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode136-只出现一次的数字"><a href="#Leetcode136-只出现一次的数字" class="headerlink" title="Leetcode136.只出现一次的数字"></a>Leetcode136.只出现一次的数字</h1><p><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">Leetcode136.只出现一次的数字</a></p>
<blockquote>
<p>根据重复数字异或等于0的性质，对所有数字进行异或。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        ret = ret ^ num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode190-颠倒二进制位"><a href="#Leetcode190-颠倒二进制位" class="headerlink" title="Leetcode190.颠倒二进制位"></a>Leetcode190.颠倒二进制位</h1><p><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">Leetcode190.颠倒二进制位</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">        ret = ret &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        ret |= (n &amp; <span class="number">1</span>);</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode231-2的幂次方"><a href="#Leetcode231-2的幂次方" class="headerlink" title="Leetcode231.2的幂次方"></a>Leetcode231.2的幂次方</h1><p><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">Leetcode231.2的幂次方</a></p>
<blockquote>
<p>2的幂次表示二进制只有一个1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.bitCount(n) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode693-交替位二进制数"><a href="#Leetcode693-交替位二进制数" class="headerlink" title="Leetcode693.交替位二进制数"></a>Leetcode693.交替位二进制数</h1><p><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/" target="_blank" rel="noopener">Leetcode693.交替位二进制数</a></p>
<blockquote>
<p>类似1010的二进制数，右移得到101，与原数每一位都不相同，异或得全1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = (n ^ (n &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> (a &amp; (a + <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统死锁知识</title>
    <url>/2020/01/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%AD%BB%E9%94%81%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h1><ul>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h1 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h1><ul>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
<h2 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h2><p>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h2 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h2><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p>在程序运行之前预防发生死锁。</p>
<h3 id="1-破坏互斥条件"><a href="#1-破坏互斥条件" class="headerlink" title="1. 破坏互斥条件"></a>1. 破坏互斥条件</h3><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>
<h3 id="2-破坏占有和等待条件"><a href="#2-破坏占有和等待条件" class="headerlink" title="2. 破坏占有和等待条件"></a>2. 破坏占有和等待条件</h3><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>
<h3 id="3-破坏不可抢占条件"><a href="#3-破坏不可抢占条件" class="headerlink" title="3. 破坏不可抢占条件"></a>3. 破坏不可抢占条件</h3><h3 id="4-破坏环路等待"><a href="#4-破坏环路等待" class="headerlink" title="4. 破坏环路等待"></a>4. 破坏环路等待</h3><p>给资源统一编号，进程只能按编号顺序来请求资源。</p>
<h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>银行家算法</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>死锁</category>
      </categories>
  </entry>
  <entry>
    <title>扑克牌顺子</title>
    <url>/2020/01/02/%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</url>
    <content><![CDATA[<h1 id="剑指Offer-扑克牌顺子"><a href="#剑指Offer-扑克牌顺子" class="headerlink" title="剑指Offer.扑克牌顺子"></a>剑指Offer.扑克牌顺子</h1><p><strong>题目描述：</strong></p>
<p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&#123;1,3,0,5,4&#125;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&#123;1,3,0,5,6&#125;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>思路：</strong></p>
<p>对元素进行排序，计算除0以外其他元素的最大差值，例如对与{1,2,3,4,5}，差值不超过长度-1，即可成为顺子，否则不行，然后确保没有除0以外的重复元素即可。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length &lt; <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == last) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sub = nums[nums.length - <span class="number">1</span>] - num;</span><br><span class="line">        <span class="keyword">if</span>(sub &gt; max) max = sub;</span><br><span class="line">        last = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(max &lt;= nums.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路没有问题，但是代码看起来不舒服，这个题因为数据量小，所以可以不考虑复杂度，看看能不能把代码改改可读性高一点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length &lt; <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> notZeroIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">            notZeroIndex++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = notZeroIndex; i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nums[nums.length - <span class="number">1</span>] - nums[notZeroIndex] &lt;= nums.length - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码量区别不大，但感觉可读性高了不少。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>第一个只出现一次的字符位置</title>
    <url>/2019/12/31/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="剑指Offer-第一个只出现一次的字符位置"><a href="#剑指Offer-第一个只出现一次的字符位置" class="headerlink" title="剑指Offer.第一个只出现一次的字符位置"></a>剑指Offer.第一个只出现一次的字符位置</h1><p><strong>题目描述：</strong></p>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: abacc</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: aabb</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>思路：</strong></p>
<p>一次遍历记录字符出现的次数，第二次遍历找结果。</p>
<p>一般可以通过HashMap来记录字符和对应次数，因为范围有限，我们可以直接使用int[]。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">        cnts[str.charAt(i)]++;</span><br><span class="line">    &#125;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnts[str.charAt(i)] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树中和为某一值的路径</title>
    <url>/2019/12/31/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="剑指Offer-二叉树中和为某一值的路径"><a href="#剑指Offer-二叉树中和为某一值的路径" class="headerlink" title="剑指Offer.二叉树中和为某一值的路径"></a>剑指Offer.二叉树中和为某一值的路径</h1><p><strong>题目描述：</strong></p>
<p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:[10,5,12,4,7], 22</span><br><span class="line">输出:[</span><br><span class="line">	[10,5,7],</span><br><span class="line">	[10,12]</span><br><span class="line">	]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>思路：</strong></p>
<p>求二叉树路径和，首先感觉是可以用递归求解的题，此题中路径为从根节点到叶节点，也就是说有一端是根，无需考虑此时的节点是否需要加入List，直接加入即可，如果可以满足条件，一定有此时的节点。</p>
<p>所以本质上就是对树进行了一次DFS，那我们是否需要剪枝呢？</p>
<p>题目没有说明每个节点都是正数，如果节点都是正数，当遍历到某一节点路径和大于target时，其子树无需判断，对于此题我们需要完全遍历。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">    backtrack(root, target, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(TreeNode root, <span class="keyword">int</span> target, ArrayList&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    path.add(root.val);</span><br><span class="line">    target -= root.val;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        ret.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        backtrack(root.left, target, path);</span><br><span class="line">        backtrack(root.right, target, path);</span><br><span class="line">    &#125;</span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的就是最后的remove()，因为遍历过程中使用的是同一个ArrayList，因此访问完之后无论如何都要删去当前节点再继续之后的遍历。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2019/12/31/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>定义一系列算法，封装每个算法，并使它们可以互换。</p>
<p>策略模式可以让算法独立于使用它的客户端。</p>
<h2 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h2><ul>
<li>Strategy 接口定义了一个算法族，它们都实现了 behavior() 方法。</li>
<li>Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/45253106/71607494-f3a4e880-2bb4-11ea-931a-848b5ff7be46.png" alt="image"></p>
<a id="more"></a>

<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"quack!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Squeak</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"squeak!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> QuackBehavior quackBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (quackBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            quackBehavior.quack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quackBehavior = quackBehavior;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Duck duck = <span class="keyword">new</span> Duck();</span><br><span class="line">        duck.setQuackBehavior(<span class="keyword">new</span> Squeak());</span><br><span class="line">        duck.performQuack();</span><br><span class="line">        duck.setQuackBehavior(<span class="keyword">new</span> Quack());</span><br><span class="line">        duck.performQuack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">squeak!</span><br><span class="line">quack!</span><br></pre></td></tr></table></figure>

<p>策略模式这个名字感觉很合适，本质上就是不同的策略，例如双十一，虽然都是优惠，但是会有不同的优惠策略，本质上都是优惠算法族，但根据实际情况选择不同的算法。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>重建二叉树</title>
    <url>/2019/12/30/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="剑指Offer-重建二叉树"><a href="#剑指Offer-重建二叉树" class="headerlink" title="剑指Offer.重建二叉树"></a>剑指Offer.重建二叉树</h1><p><strong>题目描述：</strong></p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：前序遍历序列&#123;1,2,4,7,3,5,6,8&#125;</span><br><span class="line">	 中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;</span><br><span class="line">输出：对应二叉树</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>思路：**</p>
<p>前序遍历为根-左-右，中序遍历为左-根-右</p>
<p>那么前序遍历的第一个节点为根节点，在中序遍历中找到根节点位置，则根节点左侧为左子树，右侧为右子树，接着就变成了递归问题。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reConstructBinaryTree(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span>[] in, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL &gt; preR || inL &gt; inR)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = inL; i &lt;= inR; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == pre[preL])&#123;</span><br><span class="line">            left = i - inL;</span><br><span class="line">            root.left = reConstructBinaryTree(pre, preL + <span class="number">1</span>, preL + left, in, inL, inL + left);</span><br><span class="line">            root.right = reConstructBinaryTree(pre, preL + left + <span class="number">1</span>, preR, in, inL + left + <span class="number">1</span>, inR);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上述代码进行优化，函数6个参数，每次都需要循环搜索根节点的索引值。</p>
<p>一次循环后可以将根节点的索引值进行缓存，之后直接取。</p>
<p>一个数组已经包含了二叉树的所有节点，我们可以根据前序遍历序列得到所有节点，而中序遍历的作用是区分前序中左子树和右子树分开的位置，所以我们不需要记录中序遍历序列的left和right，只需要记录left，确定左子树遍历长度即可，中序遍历数组也不需要传参，因为我们进行了缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)&#123;</span><br><span class="line">        indexes.put(in[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reConstructBinaryTree(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL &gt; preR)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line">    <span class="keyword">int</span> left = indexes.get(pre[preL]);</span><br><span class="line">    <span class="keyword">int</span> leftTreeSize = left - inL;</span><br><span class="line">    root.left = reConstructBinaryTree(pre, preL + <span class="number">1</span>, preL + leftTreeSize, inL);</span><br><span class="line">    root.right = reConstructBinaryTree(pre, preL + leftTreeSize + <span class="number">1</span>, preR, inL + leftTreeSize + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2019/12/30/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h1><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<h2 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h2><p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p>
<p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p>
<p><img src="https://user-images.githubusercontent.com/45253106/71571853-58aa0100-2b17-11ea-9a39-e15bd5f8d4f5.png" alt="image"></p>
<a id="more"></a>

<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span><br><span class="line">            o.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StatisticsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">        weatherData.reisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StatisticsDisplay.update: "</span> + temp + <span class="string">" "</span> + humidity + <span class="string">" "</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">        weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CurrentConditionsDisplay.update: "</span> + temp + <span class="string">" "</span> + humidity + <span class="string">" "</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherStation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">        CurrentConditionsDisplay currentConditionsDisplay = <span class="keyword">new</span> CurrentConditionsDisplay(weatherData);</span><br><span class="line">        StatisticsDisplay statisticsDisplay = <span class="keyword">new</span> StatisticsDisplay(weatherData);</span><br><span class="line"></span><br><span class="line">        weatherData.setMeasurements(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CurrentConditionsDisplay.update: 0.0 0.0 0.0</span><br><span class="line">StatisticsDisplay.update: 0.0 0.0 0.0</span><br><span class="line">CurrentConditionsDisplay.update: 1.0 1.0 1.0</span><br><span class="line">StatisticsDisplay.update: 1.0 1.0 1.0</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂链表的复制</title>
    <url>/2019/12/28/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="剑指Offer-复杂链表的复制"><a href="#剑指Offer-复杂链表的复制" class="headerlink" title="剑指Offer.复杂链表的复制"></a>剑指Offer.复杂链表的复制</h1><p><strong>题目描述：</strong></p>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> label;</span><br><span class="line">    RandomListNode next = <span class="keyword">null</span>;</span><br><span class="line">    RandomListNode random = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    RandomListNode(<span class="keyword">int</span> label) &#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<p>首先能想到的方法就是先生成一条只有next节点的链表，遍历复制，然后对新链表进行遍历将random指针指向对应位置，这时候我们需要知道对应位置的节点，所以在第一次遍历时用HashMap保存节点的值和对应引用，但这样的话需要保证链表中没有重复值，如果存在重复值就没办法做了，实践了一下这样的方法在nowcoder上是可以通过的。</p>
<p>上述方法借助了额外的存储空间，最大的问题是无法存在重复值，显然不是好方法，如何允许重复值，主要问题在于，旧节点的random指针指向另一个节点，我们如何在新链表中确认这个节点在什么位置呢，这样的话两个节点就需要存在关系，也就有了新的解法。</p>
<p>分三步：</p>
<ul>
<li>在每个节点后面插入复制的节点</li>
<li>对复制节点的random进行赋值，此时旧节点random指向另一个节点node，新节点只需指向node的next即可。</li>
<li>对链表进行拆分，分出新链表</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助HashMap的实现方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HashMap&lt;Integer, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    RandomListNode head = <span class="keyword">new</span> RandomListNode(pHead.label);</span><br><span class="line">    map.put(head.label, head);</span><br><span class="line">    </span><br><span class="line">    RandomListNode headret = head;</span><br><span class="line">    RandomListNode tempHead = pHead;</span><br><span class="line">    pHead = pHead.next;</span><br><span class="line">    <span class="comment">//复制链表并将节点存入HashMap</span></span><br><span class="line">    <span class="keyword">while</span>(pHead != <span class="keyword">null</span>)&#123;</span><br><span class="line">        head.next = <span class="keyword">new</span> RandomListNode(pHead.label);</span><br><span class="line">        pHead = pHead.next;</span><br><span class="line">        head = head.next;</span><br><span class="line">        map.put(head.label,head);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    head = headret;</span><br><span class="line">    pHead = tempHead;</span><br><span class="line">    <span class="comment">//确定新链表random的指向</span></span><br><span class="line">    <span class="keyword">while</span>(pHead != <span class="keyword">null</span>)&#123;</span><br><span class="line">        head.random = pHead.random == <span class="keyword">null</span>? <span class="keyword">null</span> : map.get(pHead.random.label);</span><br><span class="line">        pHead = pHead.next;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> headret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表翻倍再拆分法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">    RandomListNode cur = pHead;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandomListNode clone = <span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">        clone.next = cur.next;</span><br><span class="line">        cur.next = clone;</span><br><span class="line">        cur = clone.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立 random 链接</span></span><br><span class="line">    cur = pHead;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandomListNode clone = cur.next;</span><br><span class="line">        <span class="keyword">if</span> (cur.random != <span class="keyword">null</span>)</span><br><span class="line">            clone.random = cur.random.next;</span><br><span class="line">        cur = clone.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拆分</span></span><br><span class="line">    cur = pHead;</span><br><span class="line">    RandomListNode pCloneHead = pHead.next;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandomListNode next = cur.next;</span><br><span class="line">        cur.next = next.next;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pCloneHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂、工厂与抽象工厂模式</title>
    <url>/2019/12/22/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E3%80%81%E5%B7%A5%E5%8E%82%E4%B8%8E%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p>
<h2 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h2><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p>
<p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p>
<p><img src="https://user-images.githubusercontent.com/45253106/71435033-29178500-2722-11ea-9a0b-d49271c47954.png" alt="image"></p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> type = <span class="number">1</span>;</span><br><span class="line">        Product product;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleFactory simpleFactory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">        Product product = simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="Intent-1"><a href="#Intent-1" class="headerlink" title="Intent"></a>Intent</h2><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p>
<h2 id="Class-Diagram-1"><a href="#Class-Diagram-1" class="headerlink" title="Class Diagram"></a>Class Diagram</h2><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p>
<p>下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。</p>
<p><img src="https://user-images.githubusercontent.com/45253106/71436614-31bf8980-2729-11ea-9753-a3b17d176eac.png" alt="image"></p>
<h2 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product product = factoryMethod();</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="Intent-2"><a href="#Intent-2" class="headerlink" title="Intent"></a>Intent</h2><p>提供一个接口，用于创建 <strong>相关的对象家族</strong> 。</p>
<h2 id="Class-Diagram-2"><a href="#Class-Diagram-2" class="headerlink" title="Class Diagram"></a>Class Diagram</h2><p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p>
<p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p>
<p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p>
<p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p>
<p><img src="https://user-images.githubusercontent.com/45253106/71459865-67757880-27e4-11ea-919f-5ddcc1c9452c.png" alt="image"></p>
<h2 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractFactory abstractFactory = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line">        AbstractProductA productA = abstractFactory.createProductA();</span><br><span class="line">        AbstractProductB productB = abstractFactory.createProductB();</span><br><span class="line">        <span class="comment">// do something with productA and productB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三者有何区别"><a href="#三者有何区别" class="headerlink" title="三者有何区别"></a>三者有何区别</h1><p>三者的特点如下：</p>
<ul>
<li>简单工厂模式最大的优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。但是当需求变动的时候，需要对原有的类进行修改，违背了开放封闭原则。</li>
<li>工厂模式由于使用了多态，克服了简单工厂违背的开放封闭原则的缺点，又保持了封装对象创建过程的优点。但是由于每增加一个产品，都需要新增对应的生产工厂，导致增加额外的开发工作量。</li>
<li>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需制定他们具体的类。抽象工厂接口，应该包含所有的产品创建的抽象方法，我们可以定义实现不止一个接口，一个工厂也可以生产不止一种产品类，和工厂方法模式一样，抽象工厂模式同样实现了开发封闭原则。</li>
</ul>
<p>具体该使用怎么样的模式还是要看具体的需求。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>关于String的一些认识</title>
    <url>/2019/12/22/%E5%85%B3%E4%BA%8EString%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p>String类是Java里一个比较特殊的类，也是我们频繁用到的类，String表示字符串，用来处理程序中与字符串相关的内容。</p>
<p>之所以特殊，是因为String不是必须用new来初始化，可以用<code>=</code>进行赋值，String不是基本类型但又胜似基本类型，像是基本类型的包装类，比如Integer，可以有两种初始化方式，类都是被定义为final的，用<code>=</code>进行赋值时，其指向的地址都是栈中常量池而非堆。</p>
<a id="more"></a>

<h1 id="String有长度限制吗"><a href="#String有长度限制吗" class="headerlink" title="String有长度限制吗"></a>String有长度限制吗</h1><p>还是无意间看到了这个问题，第一反应就是：真不知道，一般我们也不会用太长的字符串，但是多了解一下也没问题，避免以后真的遇到了错误晕头转向。</p>
<p><strong>编译期</strong></p>
<p>我们用=直接对String进行赋值，最长赋值为65534，超过则会提示常量字符串过长，为什么是65534呢？</p>
<p>当我们使用字符串字面量直接定义String的时候，是会把字符串在常量池中存储一份的，其实65534是常量池的限制。</p>
<p>常量池中的每一种数据项也有自己的类型。Java中的UTF-8编码的Unicode字符串在常量池中以CONSTANT_Utf8类型表示。</p>
<p>理论上允许的的最大长度是2^16=65536。而 java class 文件是使用一种变体UTF-8格式来存放字符的，null 值使用两个 字节来表示，因此只剩下 65536－ 2 ＝ 65534个字节。</p>
<p><strong>运行期</strong></p>
<p>在String的构造方法中，count为int型，最长为Integer.MAX_VALUE也就是2^31-1，超过这个长度可能会抛出异常。</p>
<h1 id="String为什么被定义为final"><a href="#String为什么被定义为final" class="headerlink" title="String为什么被定义为final"></a>String为什么被定义为final</h1><p>我自己认为讨论这个问题更应该考虑，String为什么被设计为不可变的。</p>
<ul>
<li>定义为final使得String不可以被继承，String里的<code>value[]</code>也被定义为final，但这仅仅保证引用指向的地址不能改变，我们仍然可以改变数组内容，String在设计过程中避免了对<code>value[]</code>进行更改来保证String的不可变</li>
<li>String不可变，因而才能够实现字符串常量池，在运行时节约许多堆空间。</li>
<li>String不可变提高了数据安全性，因为我们很多时候会用到String，例如用户名密码，数据库连接名，主机名端口等等，String如果是可变的，会非常不安全。</li>
<li>String不可变使得String可读不可写，是多线程安全的。</li>
<li>String不可变，所以在它创建的时候<code>HashCode</code>就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</li>
</ul>
<p>举例说明一下String的字符串常量池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1.equals(s3));<span class="comment">//true</span></span><br><span class="line">String s2 = s2 + <span class="string">"d"</span>;</span><br><span class="line">System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">System.out.println(s2);<span class="comment">//abcd</span></span><br></pre></td></tr></table></figure>

<p>从上面的输出可以看出，通过<code>=</code>为s1赋值，其内容存在常量池中，s2指向同一个常量，s1和s2的地址相同，返回true，而s3初始化在堆中，返回false，但s1和s3的字符串内容相同，返回true，这是String重写了<code>equals()</code>的结果，之后我们改变s2的内容，但s1并未改变，s1和s2指向同一个地址，但s2修改时实际上上是创建了新的字符串<code>&quot;abcd&quot;</code>存入了字符串常量中。</p>
<h1 id="String重写equals-与hashCode"><a href="#String重写equals-与hashCode" class="headerlink" title="String重写equals()与hashCode()"></a>String重写equals()与hashCode()</h1><p>先看一下String重写<code>hashCode()</code>的方法，用到了字符串的每一个字符，乘子31，通过<code>h = 31 * h + val[i]</code>进行计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下<code>equals()</code>的重写，也很好理解很清晰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里再讨论一下为什么重写<code>equals()</code>要重写<code>hashCode()</code>呢，这个问题也常常被提起，重写<code>equals()</code>方法主要是为了实际的使用，有时候我们希望类的某些属性相同时即判定为true而不是指向的地址相同，对象的hashCode相同时对象不一定相同，对象相同时hashCode不一定相同，如果不重写<code>hashCode()</code>则可能对象相同但它们的hashCode不同。</p>
<p>不重写时，实际使用也可能出现问题，例如我们将对象存入HashMap,HashMap首先对对象进行hashCode计算，hashCode相同时再判断对象是否已经存入在对应位置上，因为没有重写，两个相同的对象拥有不同的hashCode，导致被存在了不同的位置上作为key，这就使得使用HashMap出现了问题，因为它们是相同对象，我们希望它应该是同一个key。</p>
<h1 id="String的hashCode-为什么以数字31为乘子"><a href="#String的hashCode-为什么以数字31为乘子" class="headerlink" title="String的hashCode()为什么以数字31为乘子"></a>String的hashCode()为什么以数字31为乘子</h1><p>主要是两个原因：</p>
<ul>
<li>31是一个不大不小的质数，冲突率较低</li>
<li>31 * i 可以被优化为 <code>(i &lt;&lt; 5) - i</code></li>
</ul>
<p>综合这两方面原因一般会选择31作为hashCode的乘子，大质数例如101冲突率也很低而且分布相比31更均匀，但太容易造成溢出。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>容器集合</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>树型动态规划问题-打家劫舍</title>
    <url>/2019/12/20/%E6%A0%91%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<h1 id="Leetcode336-打家劫舍-III"><a href="#Leetcode336-打家劫舍-III" class="headerlink" title="Leetcode336.打家劫舍 III"></a>Leetcode336.打家劫舍 III</h1><p><strong>题目描述：</strong></p>
<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<a id="more"></a>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<p>起初我想到的方法就是递归处理，例如对于根节点，选择偷或不偷，如果不偷，则左右子树直接递归，如果偷的话，左右子树的根节点默认不偷，然后递归，这样就写出了第一版代码。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> val1 = root.val;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) val1 += rob(root.left.left) + rob(root.left.right);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) val1 += rob(root.right.left) + rob(root.right.right);</span><br><span class="line">    <span class="keyword">int</span> val2 = rob(root.left) + rob(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(val1, val2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样很显然比较暴力，在计算爷爷节点时，需要计算两个儿子节点和四个孙子节点的结果，而计算两个儿子节点时，又要计算儿子的儿子，也就是当前节点的孙子节点，这样计算出现了重复，那么我们可以通过保留中间结果来提高性能。因为是树形结构所以选择HashMap进行缓存，写出第二版代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;TreeNode, Integer&gt; ret = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> rob(root, ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root, HashMap&lt;TreeNode, Integer&gt; ret)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ret.containsKey(root)) <span class="keyword">return</span> ret.get(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val1 = root.val;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) val1 += rob(root.left.left, ret) + rob(root.left.right, ret);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) val1 += rob(root.right.left, ret) + rob(root.right.right, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val2 = rob(root.left, ret) + rob(root.right, ret);</span><br><span class="line">    <span class="keyword">int</span> res = Math.max(val1, val2);</span><br><span class="line">    ret.put(root, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 相比第一版保留了中间结果，运行已经很快了，我自己基本也就想到这里，后来又看到了更好的解法。第二种方法计算爷爷节点时，仍然需要去找两个儿子和四个孙子节点，有没有办法让当前节点的结果只需要计算儿子节点呢，我们分析一下，你需要知道最终结果，首先要知道儿子节点的结果，但其实儿子节点的结果我们并不一定需要，因为可能儿子节点选择不偷，我们使用一个大小为2的数组来表示 <code>int[] res = new int[2]</code> 0代表不偷，1代表偷，这样的话可以得到</p>
<p><code>root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) + Math.max(rob(root.right)[0], rob(root.right)[1])</code></p>
<p><code>root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val</code></p>
<p>根据这种方法得到第三版代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = rob2(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] rob2(TreeNode root)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] left = rob2(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = rob2(root.right);</span><br><span class="line"></span><br><span class="line">    ret[<span class="number">0</span>] = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">    ret[<span class="number">1</span>] = left[<span class="number">0</span>] + right[<span class="number">0</span>] + root.val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不同方法的消耗：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th align="left">执行用时</th>
<th align="left">内存消耗</th>
</tr>
</thead>
<tbody><tr>
<td>动态规划分情况</td>
<td align="left">1 ms</td>
<td align="left">37.1 MB</td>
</tr>
<tr>
<td>动态规划记忆化</td>
<td align="left">4 ms</td>
<td align="left">41.8 MB</td>
</tr>
<tr>
<td>动态规划递归</td>
<td align="left">746 ms</td>
<td align="left">39 MB</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>两个线程交替打印</title>
    <url>/2019/12/20/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>之前面试被问到过两个线程交替打印，实现ABABABAB这样的效果，今天无意间看到一个线程1实现1-10循环打印，打印5时通知另一个线程的题目，因此来写一下，思路基本是相同的，所以只写了第二个题的代码。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>使用synchronized进行锁操作，线程1循环打印1-10，打印5时将<code>needNotice</code>置为true表示要通知线程2，然后线程1执行<code>wait()</code>释放锁进行等待，线程2得到锁，输出信息，释放锁等待下一次被通知，线程1得到锁继续循环打印。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Printer printer =  <span class="keyword">new</span> Printer();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                printer.print();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    printer.receive();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> needNotice = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(needNotice)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + num);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">5</span>) needNotice = <span class="keyword">true</span>;</span><br><span class="line">        num = num % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!needNotice)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"接到了通知"</span>);</span><br><span class="line">        needNotice = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h1><blockquote>
<p>Thread-0print1<br>Thread-0print2<br>Thread-0print3<br>Thread-0print4<br>Thread-0print5<br>Thread-1接到了通知<br>Thread-0print6<br>Thread-0print7<br>Thread-0print8<br>Thread-0print9<br>Thread-0print10<br>Thread-0print1<br>Thread-0print2<br>Thread-0print3<br>Thread-0print4<br>Thread-0print5<br>Thread-1接到了通知<br>Thread-0print6<br>Thread-0print7<br>Thread-0print8<br>Thread-0print9<br>Thread-0print10</p>
</blockquote>
<p>截取了一部分输出，程序没有设置停止操作，会一直循环，可以设置计数器控制打印次数。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表</title>
    <url>/2019/12/20/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>题目描述：</strong></p>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<p>环形链表最简单的是判断链表中是否有环，通常使用快慢指针来进行操作，那么如何确定环的入口节点在哪里呢，起初我想到的方法就是断链，通过不断的断开一个个节点，直到遍历到一个节点的next为null，它即是环入口节点，但题目要求不能修改链表，修改链表大多数时候也不符合实际要求，此时需要使用Floyd算法，用快慢指针来完成。</p>
<p>如下图，起点A，入口点C，快慢指针相遇位置B。</p>
<p>假设黑色段为x，蓝色段为y，橙色段为z，顺时针环。</p>
<p>相遇时，fast走过的长度为<br>$$<br>x + n * (y + z) + y<br>$$<br>这里n &gt;= 1，因为fast不走完一圈不可能追上slow。</p>
<p>slow走过的长度为<br>$$<br>x + m * (y + z) + y<br>$$<br>这里m为0，因为slow至多走完一圈就会被fast追上，而若走完一圈则z = 0，即slow走过的长度为x + y。</p>
<p>已知<br>$$<br>fastLength = 2 * slowLength<br>$$<br>可得<br>$$<br>x = n(y + z) - y</p>
<p>   = (n - 1) * (y + x) + z<br>$$<br>则当一个指针从A走到C经过距离x时，另一个点会从B走(n - 1) * (y + x) + z距离，也会到达C点，而C点即是环入口点。</p>
<p><img src="https://user-images.githubusercontent.com/45253106/71247703-3f08fc80-2354-11ea-8bc0-44ba6e45b78c.png" alt="image"></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode slow = head.next;</span><br><span class="line">    ListNode fast = head.next.next;</span><br><span class="line">    <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head != slow)&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议知识整理</title>
    <url>/2019/12/19/http%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="URI-Uniform-Resource-Identifier"><a href="#URI-Uniform-Resource-Identifier" class="headerlink" title="URI(Uniform Resource Identifier)"></a>URI(Uniform Resource Identifier)</h2><p>URI包括URL(Uniform Resource Locator)和URN(Uniform Resource Name)</p>
<p>URL例如<a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></p>
<p>URN例如urn:isbn:0451450523</p>
<a id="more"></a>

<h2 id="请求和响应报文"><a href="#请求和响应报文" class="headerlink" title="请求和响应报文"></a>请求和响应报文</h2><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p><img src="https://user-images.githubusercontent.com/45253106/71391276-73bfd100-263e-11ea-9b6a-20843fad040e.png" alt="image"></p>
<p>请求行：包括请求方法、URL、使用的HTTP协议版本</p>
<p>请求头：后面整理</p>
<p>空行：用来分隔header和body</p>
<p>请求体：具体内容</p>
<h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p><img src="https://user-images.githubusercontent.com/45253106/71391316-981bad80-263e-11ea-9581-df6630532fda.png" alt="image"></p>
<p>响应状态行：使用的HTTP协议版本、返回状态码</p>
<p>响应头：后面整理</p>
<p>空行：用来分隔header和body</p>
<p>响应体：具体内容</p>
<h1 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h1><p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><blockquote>
<p>获取资源</p>
</blockquote>
<p>当前网络请求中，绝大部分使用的是 GET 方法。</p>
<h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><blockquote>
<p>获取报文头部</p>
</blockquote>
<p>和 GET 方法类似，但是不返回报文实体主体部分。</p>
<p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><blockquote>
<p>传输实体主体</p>
</blockquote>
<p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p>
<h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><blockquote>
<p>上传文件</p>
</blockquote>
<p>不带验证机制，存在安全性问题，一般不使用。</p>
<h2 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h2><blockquote>
<p>对资源进行部分修改</p>
</blockquote>
<p>PUT也可以用于修改资源，但只能进行完全替代，PATCH允许部分修改。</p>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><blockquote>
<p>删除文件</p>
</blockquote>
<p>与PUT一样不带验证机制。</p>
<h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><blockquote>
<p>查询支持的方法</p>
</blockquote>
<p>查询指定的 URL 能够支持的方法。</p>
<p>会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p>
<h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><blockquote>
<p>要求在与代理服务器通信时建立隧道</p>
</blockquote>
<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><blockquote>
<p>追踪路径</p>
</blockquote>
<p>服务器会将通信路径返回给客户端。</p>
<p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p>
<p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>
<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h2 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h2><ul>
<li><strong>100 Continue：</strong>表明目前为止都很正常，客户端可以继续发送请求或忽略这个响应。</li>
</ul>
<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong>：请求成功处理，但响应报文不包含实体的主体部分。一般在只需要从客户端向服务端发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong>：表示客户端进行了范围请求，响应报文包含由Content-Range 指定范围的实体内容。</li>
</ul>
<h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul>
<li><strong>400 Bad Request</strong>：请求报文中存在语法错误</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
<li><strong>404 Not Found</strong></li>
</ul>
<h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h1 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h1><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p>
<h2 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h2><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>控制不再转发给代理的首部字段、管理持久连接</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody></table>
<h2 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h2><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言（自然语言）</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web 认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与 If-Modified-Since 相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP 客户端程序的信息</td>
</tr>
</tbody></table>
<h2 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h2><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定 URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP 服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody></table>
<h2 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h2><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的 URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody></table>
<h1 id="GET和POST的比较"><a href="#GET和POST的比较" class="headerlink" title="GET和POST的比较"></a>GET和POST的比较</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>GET用于获取资源，而POST用于传输实体主体。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p>
<p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /test/demo_form.asp HTTP/1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure>

<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>
<p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>
<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p>
<p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p>
<h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>
<p>所有的安全方法也都是幂等的。</p>
<p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>
<p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 1nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 2nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 3rd row</span><br></pre></td></tr></table></figure>

<h2 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h2><p>如果要对响应进行缓存，需要满足以下条件：</p>
<ul>
<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>
<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li>
</ul>
<h1 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h2 id="Cookie-与-Session-选择"><a href="#Cookie-与-Session-选择" class="headerlink" title="Cookie 与 Session 选择"></a>Cookie 与 Session 选择</h2><ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTP 有以下安全性问题：</p>
<ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p>
<p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
<h2 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h2><p>SSL 提供报文摘要功能来进行完整性保护。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<h2 id="HTTPS-的缺点"><a href="#HTTPS-的缺点" class="headerlink" title="HTTPS 的缺点"></a>HTTPS 的缺点</h2><ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>http</category>
      </categories>
      <tags>
        <tag>http协议</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>树的层次遍历</title>
    <url>/2019/12/19/%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="Leetcode637-二叉树的层平均值"><a href="#Leetcode637-二叉树的层平均值" class="headerlink" title="Leetcode637.二叉树的层平均值"></a>Leetcode637.二叉树的层平均值</h1><p><strong>题目描述：</strong></p>
<p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">输出: [3, 14.5, 11]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>思路：**</p>
<p>典型的BFS，用队列保存层节点。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Double&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    que.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = que.size();</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            TreeNode node = que.poll();</span><br><span class="line">            sum += node.val;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) que.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) que.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        ret.add(sum / size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode513-树左下角的值"><a href="#Leetcode513-树左下角的值" class="headerlink" title="Leetcode513.树左下角的值"></a>Leetcode513.树左下角的值</h1><p><strong>题目描述：</strong></p>
<p>给定一个二叉树，在树的最后一行找到最左边的值。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">        1</span><br><span class="line">       / \</span><br><span class="line">      2   3</span><br><span class="line">     /   / \</span><br><span class="line">    4   5   6</span><br><span class="line">       /</span><br><span class="line">      7</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<p>BFS层次遍历，保留每层第一个节点的val</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    que.offer(root);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = que.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            TreeNode node = que.poll();</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) ret = node.val;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) que.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) que.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做法是和上面的题类似，但上面的题需要每层的每个节点，但这个题只需要最左节点，假设需要的是最右节点的话，我们只需要遍历至结束即可，不需要size也不需要for循环，但要求的是左节点，那么我们可以通过改变遍历顺序完成，毕竟左和右的地位相同。</p>
<p><strong>改进</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    que.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        root = que.poll();</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) que.offer(root.right);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) que.offer(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>树的递归问题</title>
    <url>/2019/12/14/%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>因为树的性质，许多问题可以用递归求解，本文总结一下树常见的问题的递归方法</p>
</blockquote>
<a id="more"></a>

<h1 id="Leetcode104-树的深度"><a href="#Leetcode104-树的深度" class="headerlink" title="Leetcode104.树的深度"></a>Leetcode104.树的深度</h1><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">Leetcode104.树的深度</a></p>
<blockquote>
<p>树的深度 = 左右子树深度较大值 + 1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode110-平衡二叉树"><a href="#Leetcode110-平衡二叉树" class="headerlink" title="Leetcode110.平衡二叉树"></a>Leetcode110.平衡二叉树</h1><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">Leetcode110.平衡二叉树</a></p>
<blockquote>
<p>平衡二叉树 = 左右子树为平衡二叉树 + 左右子树高度差 &lt;= 1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> depth(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">    <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">    <span class="keyword">if</span>(right ==  -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(right - left) &gt; <span class="number">1</span> ? -<span class="number">1</span> : Math.max(left, right) + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode543-二叉树的直径"><a href="#Leetcode543-二叉树的直径" class="headerlink" title="Leetcode543.二叉树的直径"></a>Leetcode543.二叉树的直径</h1><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">Leetcode543.二叉树的直径</a></p>
<blockquote>
<p>二叉树直径 = 二叉树任意两个结点之间路径的最大值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">    max = Math.max(max, left + right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode226-翻转二叉树"><a href="#Leetcode226-翻转二叉树" class="headerlink" title="Leetcode226.翻转二叉树"></a>Leetcode226.翻转二叉树</h1><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">Leetcode226.翻转二叉树</a></p>
<blockquote>
<p>翻转二叉树 = 翻转左子树 + 翻转右子树 + 交换左右子树位置</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode left = invertTree(root.left);</span><br><span class="line">    TreeNode right = invertTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode617-合并二叉树"><a href="#Leetcode617-合并二叉树" class="headerlink" title="Leetcode617.合并二叉树"></a>Leetcode617.合并二叉树</h1><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">Leetcode617.合并二叉树</a></p>
<blockquote>
<p>合并二叉树 = 相加根结点值 + 合并左子树 + 合并右子树</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span>(t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line"></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">    root.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">    root.right = mergeTrees(t1.right, t2.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode112-路径总和"><a href="#Leetcode112-路径总和" class="headerlink" title="Leetcode112.路径总和"></a>Leetcode112.路径总和</h1><p><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">Leetcode112.路径总和</a></p>
<blockquote>
<p>判断是否存在一个路径和的值是给定的值</p>
<p>是否存在这样的路径 = 和减当前节点值 + 左子树是否存在这样的路径/右子树是否存在这样的路径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode437-路径总和-III"><a href="#Leetcode437-路径总和-III" class="headerlink" title="Leetcode437. 路径总和 III"></a>Leetcode437. 路径总和 III</h1><p><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">Leetcode437. 路径总和 III</a></p>
<blockquote>
<p>对于包括根的路径，可以减去根的值之后对左子树和右子树进行递归操作</p>
<p>此题不一定包括根，那么分情况为包括根和不包括根，前者用上面的方法，后者即对左子树和右子树进行递归。</p>
<p>也就是说此题通过两个递归完成。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSumStartWithRoot</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val == sum) ret++;</span><br><span class="line">    ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode572-另一个树的子树"><a href="#Leetcode572-另一个树的子树" class="headerlink" title="Leetcode572.另一个树的子树"></a>Leetcode572.另一个树的子树</h1><p><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">Leetcode572.另一个树的子树</a></p>
<blockquote>
<p>一个树是否为另一个树的子树 = 遍历所有节点使每个节点成为另一个树根节点，遍历判断是否相同。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//题中给出s，t不为空，因此无需判断t，只判断s即可</span></span><br><span class="line">    <span class="keyword">return</span> isSubtreeWithRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtreeWithRoot</span><span class="params">(TreeNode s, TreeNode t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.val != t.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtreeWithRoot(s.left, t.left) &amp;&amp; isSubtreeWithRoot(s.right, t.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode107-对称二叉树"><a href="#Leetcode107-对称二叉树" class="headerlink" title="Leetcode107.对称二叉树"></a>Leetcode107.对称二叉树</h1><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">Leetcode107.对称二叉树</a></p>
<blockquote>
<p>二叉树是否对称 = 左右子树对称</p>
<p>两棵树对称 = 树1左对称树2右 + 树1右对称树2左</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isMirror(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode t1, TreeNode t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 ==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(t1 == <span class="keyword">null</span> || t2 ==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (t1.val == t2.val) &amp;&amp; isSymmetric(t1.left, t2.right) &amp;&amp; isSymmetric(t2.left, t1.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode111-二叉树最小深度"><a href="#Leetcode111-二叉树最小深度" class="headerlink" title="Leetcode111.二叉树最小深度"></a>Leetcode111.二叉树最小深度</h1><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">Leetcode111.二叉树最小深度</a></p>
<blockquote>
<p>二叉树最小深度 = 左右子树最小深度的小值 + 1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = minDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = minDepth(root.right);</span><br><span class="line">    <span class="comment">//注意深度为0时需要单独判断，深度为0代表没有而不是为0</span></span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">0</span> || right ==<span class="number">0</span>) <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode404-左叶子之和"><a href="#Leetcode404-左叶子之和" class="headerlink" title="Leetcode404.左叶子之和"></a>Leetcode404.左叶子之和</h1><p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">Leetcode404.左叶子之和</a></p>
<blockquote>
<p> 对于左子树，要判断是否为叶子节点</p>
<p>对于右子树，直接递归</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(isLeaf(root.left)) <span class="keyword">return</span> root.left.val + sumOfLeftLeaves(root.right);</span><br><span class="line">    <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode124-二叉树的最大路径和"><a href="#Leetcode124-二叉树的最大路径和" class="headerlink" title="Leetcode124.二叉树的最大路径和"></a>Leetcode124.二叉树的最大路径和</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">Leetcode124.二叉树的最大路径和</a></p>
<blockquote>
<p>由下向上DFS求出每个节点的最大贡献</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = Math.max(dfs(root.left), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> right = Math.max(dfs(root.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    max = Math.max(max, left + right + root.val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root.val + Math.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode687-最长同值路径"><a href="#Leetcode687-最长同值路径" class="headerlink" title="Leetcode687.最长同值路径"></a>Leetcode687.最长同值路径</h1><p><a href="https://leetcode-cn.com/problems/longest-univalue-path/" target="_blank" rel="noopener">Leetcode687.最长同值路径</a></p>
<blockquote>
<p>由下向上DFS求以当前节点为一端的最长同值路径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = dfs(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = dfs(root.right);</span><br><span class="line">    <span class="keyword">int</span> leftNum = root.left != <span class="keyword">null</span> &amp;&amp; root.left.val == root.val ? left + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightNum = root.right != <span class="keyword">null</span> &amp;&amp; root.right.val == root.val ? right + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    max = Math.max(max, leftNum + rightNum);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftNum, rightNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread Local分析与扩展</title>
    <url>/2019/12/14/Thread-Local%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>ThreadLocal是一个非常重要的类，用来提供线程级别的变量，变量只对当前线程可见，记得我第一次接触时觉得，还有这种操作？每个线程有独立的属于自己的变量，相比于“使用锁控制共享变量”，ThreadLocal更加效率简单。</p>
<p>那么ThreadLocal类最重要的，就是<strong>如何让线程维护自己的变量副本</strong>。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Thread类中的相关变量"><a href="#Thread类中的相关变量" class="headerlink" title="Thread类中的相关变量"></a>Thread类中的相关变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained    </span></span><br><span class="line"><span class="comment">    * by the ThreadLocal class. */</span></span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Thread类中的变量<code>threadLocals</code>是<code>ThreadLocalMap</code>类型，而<code>ThreadLocalMap</code>就是实现ThreadLocal的重要类。</p>
<h2 id="ThreadLocalMap介绍"><a href="#ThreadLocalMap介绍" class="headerlink" title="ThreadLocalMap介绍"></a>ThreadLocalMap介绍</h2><p><code>ThreadLocalMap</code>是 <code>ThreadLocal</code>的内部类，他是类 <code>Map</code>结构，也是存储 <code>K-V</code>结构数据，并用 <code>Entry</code>封装 <code>K-V</code>。不同的是 <code>ThreadLocalMap</code>的 <code>Entry</code>的 <code>Key</code>只能是 <code>ThreadLocal</code>类型对象，并且是一个弱引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说线程通过一个类Map数据结构 <code>ThreadLocal.ThreadLocalMap</code> 来存储属于自己的线程变量。</p>
<h2 id="ThreadLocal的get与set"><a href="#ThreadLocal的get与set" class="headerlink" title="ThreadLocal的get与set"></a>ThreadLocal的get与set</h2><p><code>ThreadLocalMap</code>赋值、取值操作的入口在其外部类 <code>ThreadLocal</code>中。</p>
<p><code>set(v)</code>方法内调用 <code>ThreadLocalMap</code> 的 <code>set(this,v)</code>方法存值。（类似 <code>Map</code>的 <code>put(k,v)</code>方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>get()</code>方法内调用 <code>ThreadLocalMap</code>的 <code>getEntry(this)</code>方法取值（类似 <code>Map</code>的 <code>get(k)</code>方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代码可以看出：</p>
<ul>
<li>第一次操作线程的 <code>ThreadLocalMap</code>属性时，会初始化一个 <code>ThreadLocal.ThreadLocalMap</code>， <code>set(v)</code>会存入以参数为 <code>Value</code>的 <code>K/V</code>数据， <code>get()</code>会存入以 <code>null</code>为 <code>value</code>的 <code>K/V</code>数据。</li>
</ul>
<ul>
<li><code>ThreadLocal.ThreadLocalMap</code> 存值操作入口是 <code>ThreadLocal.set(v)</code>方法，并以当前 <code>ThreadLocal</code>变量为 <code>key</code>，参数为 <code>value</code>。</li>
<li><code>ThreadLocal.ThreadLocalMap</code> 取值操作入口是 <code>ThreadLocal.get(v)</code>方法， <code>key</code>为当前ThreadLocal变量。</li>
</ul>
<h2 id="总结ThreadLocal的实现方式"><a href="#总结ThreadLocal的实现方式" class="headerlink" title="总结ThreadLocal的实现方式"></a>总结ThreadLocal的实现方式</h2><p>起初知道<code>ThreadLocal</code>时，认为是开辟一个大的空间存储，然后保存每个元素对应的线程名，当每个线程操作变量时根据线程名进行对应更改。其实仔细想想会发现，这种想法其实是类似于最开始提到的共享空间。</p>
<p><code>ThreadLocal</code>拥有内部类<code>ThreadLocalMap</code>，以<code>ThreadLocal</code>作为key，对应的值作为value，而每个<code>Thread</code>拥有一个<code>ThreadLocalMap</code>的变量，当线程对<code>ThreadLocal</code>类型变量进行<code>get</code>和<code>set</code>时，方法会首先获取当前线程，并获得线程的<code>ThreadLocalMap</code>，从而进行<code>get</code>和<code>set</code>操作。</p>
<ul>
<li>当我们定义一个 <code>ThreadLocal</code>变量时，其实就是在定义一个 <code>Key</code>。</li>
<li>当我们调用 <code>set(v)</code>方法时，就是以当前 <code>ThreadLocal</code>变量为 <code>key</code>，传入参数为 <code>value</code>，向 <code>ThreadLocal.ThreadLocalMap</code>存数据。</li>
<li>当我们调用 <code>get()</code>方法时，就是以当前 <code>ThreadLocal</code>变量为 <code>key</code>，从 <code>ThreadLocal.ThreadLocalMap</code>取对应的数据。</li>
</ul>
<h1 id="ThreadLocalMap扩展"><a href="#ThreadLocalMap扩展" class="headerlink" title="ThreadLocalMap扩展"></a>ThreadLocalMap扩展</h1><h2 id="ThreadLocalMap的Hash冲突解决办法"><a href="#ThreadLocalMap的Hash冲突解决办法" class="headerlink" title="ThreadLocalMap的Hash冲突解决办法"></a>ThreadLocalMap的Hash冲突解决办法</h2><p>采用<strong>线性探测</strong>的方式，根据 <code>key</code>计算 <code>hash</code>值，如果出现冲突，则向后探测，当到哈希表末尾的时候再从0开始，直到找到一个合适的位置。</p>
<p>这种算法也决定了 <code>ThreadLocalMap</code>不适合存储大量数据。</p>
<h2 id="ThreadLocalMap的扩容问题"><a href="#ThreadLocalMap的扩容问题" class="headerlink" title="ThreadLocalMap的扩容问题"></a>ThreadLocalMap的扩容问题</h2><p><code>ThreadLocalMap</code>初始大小为 <code>16</code>，加载因子为 <code>2/3</code>，当 <code>size</code>大于 <code>threshold</code>时，就会进行扩容。</p>
<p>扩容时，新建一个大小为原来数组长度的<strong>两倍</strong>的数组，然后遍历旧数组中的 <code>entry</code>并将其插入到新的hash数组中，在扩容的时候，会把 <code>key</code>为 <code>null</code>的 <code>Entry</code>的 <code>value</code>值设置为 <code>null</code>，以便内存回收，减少内存泄漏问题。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>记关于Integer和int的踩坑</title>
    <url>/2019/12/11/%E8%AE%B0%E5%85%B3%E4%BA%8EInteger%E5%92%8Cint%E7%9A%84%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>某次做算法题的时候突然在考虑这个题里用List的话，需不需要考虑不把null存进去，我们知道List是允许存null的，不过这不是重点，总之不知道怎么就去用了增强for循环。</p>
<h1 id="踩坑经历"><a href="#踩坑经历" class="headerlink" title="踩坑经历"></a>踩坑经历</h1><p>使用增强for循环遍历时报了异常，然后转而直接用迭代器遍历没有报错，我们知道增强for循环属于语法糖，编译后还是使用迭代器方法进行遍历操作的，那为什么用增强for循环报错了呢？且并没有在遍历过程中进行增删操作，我们知道可以使用iterator.remove()进行操作，如果直接操作会改变迭代器，导致fail-fast。</p>
<p>很快发现了问题所在，我在foreach中使用了int而非Integer，我们知道int的默认值为0，它无法表示null，因此当定义为int，而遍历到null元素时，就会出现NullPointerException。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个更大元素</title>
    <url>/2019/12/11/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="Leetcode739-每日温度"><a href="#Leetcode739-每日温度" class="headerlink" title="Leetcode739.每日温度"></a>Leetcode739.每日温度</h1><p><strong>题目描述：</strong></p>
<p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[73, 74, 75, 71, 69, 72, 76, 73]</span><br><span class="line">输出：[1, 1, 4, 2, 1, 1, 0, 0]</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<p>根据题目的描述，实际上是找数组中元素比当前元素大的下一个元素和当前元素之间的距离，最简单的方法就是双重遍历，对于每一个元素向后遍历即可，但效率较低，例如比第一个元素大的元素在数组末尾，我们就要遍历一遍，而中间遍历的有些元素已经可以确定它的下一个更大元素的位置了，因此我们用栈保存遍历过的元素，对于当前元素和栈顶比较，大于栈顶说明当前元素是栈顶元素的下一个更大元素，为了计算距离我们保存他们的索引，时间是线性。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = T.length;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Stack&lt;Integer&gt; index = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> curIndex = <span class="number">0</span>; curIndex &lt; n; curIndex++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!index.isEmpty() &amp;&amp; T[curIndex] &gt; T[index.peek()])&#123;</span><br><span class="line">            <span class="keyword">int</span> preIndex = index.pop();</span><br><span class="line">            ans[preIndex] = curIndex - preIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        index.push(curIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>栈实现括号匹配</title>
    <url>/2019/12/11/%E6%A0%88%E5%AE%9E%E7%8E%B0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="Leetcode20-有效的括号"><a href="#Leetcode20-有效的括号" class="headerlink" title="Leetcode20.有效的括号"></a>Leetcode20.有效的括号</h1><p><strong>题目描述：</strong><br>给定一个只包括<code>&#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39;</code>的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code>输入: &quot;()&quot;
输出: true</code></pre><hr>
<pre><code>输入: &quot;()[]{}&quot;
输出: true</code></pre><hr>
<pre><code>输入: &quot;(]&quot;
输出: false</code></pre><hr>
<pre><code>输入: &quot;([)]&quot;
输出: false</code></pre><hr>
<pre><code>输入: &quot;{[]}&quot;
输出: true</code></pre><p><strong>思路：</strong></p>
<p>括号匹配是最常见的栈操作问题，在初学栈时基本都会拿括号匹配来练习，遇到左括号入栈，遇到右括号则弹出栈顶元素进行匹配，当遍历结束时栈中为空则匹配成功。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'&#123;'</span> || c == <span class="string">'['</span>) &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> cStack = stack.pop();</span><br><span class="line">            <span class="keyword">boolean</span> b1 = c == <span class="string">')'</span> &amp;&amp; cStack != <span class="string">'('</span>;</span><br><span class="line">            <span class="keyword">boolean</span> b2 = c == <span class="string">']'</span> &amp;&amp; cStack != <span class="string">'['</span>;</span><br><span class="line">            <span class="keyword">boolean</span> b3 = c == <span class="string">'&#125;'</span> &amp;&amp; cStack != <span class="string">'&#123;'</span>;</span><br><span class="line">            <span class="keyword">if</span> (b1 || b2 || b3) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最小值栈</title>
    <url>/2019/12/11/%E6%9C%80%E5%B0%8F%E5%80%BC%E6%A0%88/</url>
    <content><![CDATA[<h1 id="Leetcode155-最小栈"><a href="#Leetcode155-最小栈" class="headerlink" title="Leetcode155.最小栈"></a>Leetcode155.最小栈</h1><p><strong>题目描述：</strong></p>
<p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li>push(x) – 将元素 x 推入栈中。</li>
<li>pop() – 删除栈顶的元素。</li>
<li>top() – 获取栈顶元素。</li>
<li>getMin() – 检索栈中的最小元素。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code>MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.</code></pre><p><strong>思路：</strong></p>
<p>思考一下，当我们要寻找一个n个元素的最小值时，首先想到的就是对集合元素进行遍历，但这是效率很低的方法，因为并不是直接给了我们这样一个集合，栈中的每个元素都会经过入栈操作，那么我们可以用变量保留最小值。继续考虑，如果我们保留一个最小值，当这个最小值出栈的时候该如何做，我们又需要对栈中其他元素进行遍历才行，这样只是对于之前的方法稍微优化了一下，但仍然需要遍历操作。如果不需要遍历的话，那么我们一定需要保存多个值，也就是空间复杂度O(n)，我们可以将入栈后的元素按大小顺序保存在另一个集合里，获取最小值时直接获取集合中的最小值，出栈时集合里的元素同时出栈，但这样要求我们在集合元素出栈时可以做到O(1)，如果我们也用栈来保存这个最小值集合，与数据栈同进同出，就可以完成，保证栈每个状态都在最小值栈有对应的状态即可。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        dataStack.push(x);</span><br><span class="line">        min = Math.min(min, x);</span><br><span class="line">        minStack.push(min);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minStack.pop();</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列相互实现</title>
    <url>/2019/12/10/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9B%B8%E4%BA%92%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Leetcode232-用栈实现队列"><a href="#Leetcode232-用栈实现队列" class="headerlink" title="Leetcode232.用栈实现队列"></a>Leetcode232.用栈实现队列</h1><p><strong>题目描述：</strong></p>
<p>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) – 将一个元素放入队列的尾部。</li>
<li>pop() – 从队列首部移除元素。</li>
<li>peek() – 返回队列首部的元素。</li>
<li>empty() – 返回队列是否为空。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code>MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);  
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false</code></pre><p><strong>思路：</strong></p>
<p>栈与队列的区别就是栈是先进后出的数据结构，在一端进行操作，队列是先进先出，在两端进行操作，因此我们使用两个栈来实现队列的操作，一个栈进行push操作，当需要pop时将in栈中元素加入out，即元素进入in后又出来进入out，这样操作使得out栈中出栈的顺序恰好是元素进栈顺序，实现了先进先出，当out栈空时进行换栈操作。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; in;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.pop(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">in2out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!in.isEmpty())&#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode225-用队列实现栈"><a href="#Leetcode225-用队列实现栈" class="headerlink" title="Leetcode225.用队列实现栈"></a>Leetcode225.用队列实现栈</h1><p><strong>题目描述：</strong></p>
<p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) – 元素 x 入栈</li>
<li>pop() – 移除栈顶元素</li>
<li>top() – 获取栈顶元素</li>
<li>empty() – 返回栈是否为空</li>
</ul>
<p><strong>思路：</strong></p>
<p>与栈实现队列类似，首先能想到的就是利用两个队列来做，一个队列维护入栈，当需要出栈时将其他元素加入另一个队列，并将两个队列的作用互换。</p>
<p>然而其实一个队列就可以实现栈操作，这与栈实现队列不同之处在于，栈是一个一端操作的数据结构，我们用一个栈无论如何也没办法完成队列操作，但队列是两端操作，用一个队列完全可以实现栈操作，每次需要出栈时将除最后一个元素外的其他元素出队再入队即可，或是入栈时将其他元素出队再入队，出栈直接出，效果相同。(因为要获取栈顶元素，所以最好还是在进队的时候就进行操作)</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">        <span class="keyword">while</span>(cnt-- &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            queue.add(queue.remove());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>Leetcode</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2019/12/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>单例模式是一种最简单的设计模式，指对于一个类，在整个程序中仅有一个实类，其他类访问的都是同一个实例。</p>
<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><blockquote>
<p>单例模式分为饿汉式和懒汉式</p>
</blockquote>
<p>单例模式一般分为三部分：</p>
<ul>
<li>构造函数私有化</li>
<li>类的实例成员变量</li>
<li>调用类的实例的方法</li>
</ul>
<h2 id="饿汉式单例模式写法"><a href="#饿汉式单例模式写法" class="headerlink" title="饿汉式单例模式写法"></a><strong>饿汉式单例模式写法</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顾名思义饿汉式即非常饥饿，无论是否用到此类，都生成类的实例，在类初始化时即被创建，不存在线程安全问题，但如果程序中没有使用到该类，会造成空间浪费。</p>
<h2 id="懒汉式单例模式写法"><a href="#懒汉式单例模式写法" class="headerlink" title="懒汉式单例模式写法"></a><strong>懒汉式单例模式写法</strong></h2><h3 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a><strong>写法一</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顾名思义懒汉式即很懒，直到需要类实例的时候才去创建它，上面是懒汉式最简单的写法，但很明显无法保证线程安全，当一个线程进入if判断但并未创建实例时，另一个线程也同时进入了if判断，会导致创建两个不同的实例，违背了单例模式设计原则。</p>
<h3 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a><strong>写法二</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程不安全？那把方法改为同步方法即可，但想想看，这样的话每次访问都需要同步进行，而实际上我们只需要一次同步操作，即当实例未被创建时，此后的同步操作是无意义的。</p>
<h3 id="写法三"><a href="#写法三" class="headerlink" title="写法三"></a><strong>写法三</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为对类对象进行加锁，同时使用了双重检验，因为如果一次判断的话，仍然会出现两个线程同时进入if判断里，只是其中一个要等待锁，结果还是创建了两个对象，双重判定避免了这种情况，但仍存在问题，我们知道JVM的引用赋值操作并非原子操作，而是分为<code>分配对象内存空间</code>、<code>初始化对象</code>、<code>将引用指向分配的内存地址</code>，而执行时会因为JVM优化导致指令重排序，例如可能先指向内存地址，再初始化对象，如果线程1的执行顺序为1-3-2，当线程正在进行了步骤3但还未完成步骤2的执行时，线程2调用<code>getInstance()</code>方法，此时<code>instance</code>不为<code>null</code>，因此返回了并未初始化完成的实例，这就是双重检查锁导致的问题。</p>
<h3 id="写法四"><a href="#写法四" class="headerlink" title="写法四"></a><strong>写法四</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用volatile关键字禁止指令重排，保证在写操作没有完成之前不能调用读操作。volatile的两个特性一个是可见性另一个是有序性。此方法适用于JDK1.5以后。</p>
<h3 id="写法五"><a href="#写法五" class="headerlink" title="写法五"></a><strong>写法五</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用静态内部类的特点实现懒加载，在调用<code>getInstance之前不会对</code>SingletonHolder`进行初始化。</p>
<h3 id="写法六"><a href="#写法六" class="headerlink" title="写法六"></a><strong>写法六</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingleTon&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类的创建是线程安全的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>链表求和</title>
    <url>/2019/12/09/%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<p><strong>题目描述：</strong></p>
<p>给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。<br><strong>示例：</strong></p>
<pre><code>输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出: 7 -&gt; 8 -&gt; 0 -&gt; 7</code></pre><p><strong>思路：</strong></p>
<p>两个数按位置相加，需要考虑的就是进位，还有链表长度不一的情况，因为要从链表末尾开始操作，我们需要先对链表进行反转，题目中问到了链表不能翻转如何操作，我使用了将节点入栈的方法，但本质上也是翻转，每次从栈中取出2个数相加，保留进位即可，栈不空则继续，同时要考虑最后栈空但还有进位的情况。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1 = buildStack(l1);</span><br><span class="line">    Stack&lt;Integer&gt; s2 = buildStack(l2);</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!s1.isEmpty() || !s2.isEmpty() || carry != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = s1.isEmpty() ? <span class="number">0</span> : s1.pop();</span><br><span class="line">        <span class="keyword">int</span> y = s2.isEmpty() ? <span class="number">0</span> : s2.pop();</span><br><span class="line">        <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Stack&lt;Integer&gt; <span class="title">buildStack</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(node.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <url>/2019/12/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="Leetcode-19删除链表的倒数第N个节点"><a href="#Leetcode-19删除链表的倒数第N个节点" class="headerlink" title="Leetcode.19删除链表的倒数第N个节点"></a>Leetcode.19删除链表的倒数第N个节点</h1><p><strong>题目描述：</strong></p>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p><strong>示例：</strong></p>
<pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</code></pre><p><strong>思路：</strong></p>
<p>如果是数组删除某个位置的元素可以直接访问，对于链表我们则需要遍历，但因为是倒数，我们没办法确定遍历到哪里，链表也非双向，因此首先能想到的就是两次遍历，第一次遍历确定链表长度，得到需要删除的节点位置，第二次遍历删除。</p>
<p>但是对于链表问题，经常有更好的方法，这个题可以使用双指针，使用两次遍历是因为我们无法确定在一次遍历时该在何处停止，原因是因为不知道链表有多长，那么我们只要让一个指针先移动n步，然后让一个新指针开始同时从头走，当前一个指针遍历结束后，后一个指针的位置就是我们要删除节点的前一节点，将它指向下下个节点即可。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode pre = head;</span><br><span class="line">    ListNode next = head;</span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="keyword">null</span>) <span class="keyword">return</span> head.next;</span><br><span class="line">    <span class="keyword">while</span>(pre.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    next.next = next.next.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这个题给定n是有效的，所以没有过多考虑代码的鲁棒性，如果不确定n是否有效，例如n大于链表长度，我们需要在循环中判断是否已经遍历到了尾部。</p>
<p>另外，在pre遍历结束后判断了pre为null的情况，此时要删除的是第一个节点，因为第一个节点没有上一个节点所以需要单独判断，我们也可以为链表添加一个哑节点，使得能删除的每个节点都有上一个节点。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池的使用</title>
    <url>/2019/12/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h1><p>就不贴什么定义了，用自己的理解说一下，线程池就是维护了一定量线程用来执行任务，我们要创建线程执行任务时，直接将任务交给线程池，线程池分配给线程池中的线程去执行，可以对线程池中的线程进行分配和回收，不需要每次都创建新的线程，基本所有的池作用都类似，例如数据库连接池之类的。</p>
<h1 id="使用线程池的优点"><a href="#使用线程池的优点" class="headerlink" title="使用线程池的优点"></a>使用线程池的优点</h1><ul>
<li><p>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p>
</li>
<li><p>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止消耗过多的内存</p>
</li>
<li><p>方便管理，可以将一个线程池交给容器去管理</p>
</li>
</ul>
<h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>ThreadPoolExecutor类实现Executor和ExecutorService接口，是线程池操作的基本类，常用的四种线程池底层都是对ThreadPoolExecutor的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>corePoolSize 核心线程数，指保留的线程池大小（不超过maximumPoolSize值时，线程池中最多有corePoolSize 个线程工作）。</p>
</li>
<li><p>maximumPoolSize 指的是线程池的最大大小（线程池中最大有corePoolSize 个线程可运行）</p>
</li>
<li><p>keepAliveTime 指的是空闲线程结束的超时时间（当一个线程不工作时，过keepAliveTime 长时间将停止该线程）。</p>
</li>
<li><p>unit 是一个枚举，表示 keepAliveTime 的单位（有NANOSECONDS, MICROSECONDS,</p>
</li>
</ul>
<p>MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS，7个可选值）。</p>
<ul>
<li><p>workQueue 表示存放任务的队列（存放需要被线程池执行的线程队列）。</p>
</li>
<li><p>threadFactory 执行程序创建新线程时使用的工厂。</p>
</li>
<li><p>handler 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。</p>
</li>
</ul>
<h1 id="四种线程池"><a href="#四种线程池" class="headerlink" title="四种线程池"></a>四种线程池</h1><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><strong>newSingleThreadExecutor</strong></h2><blockquote>
<p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此线程池核心线程为1，不回收线程，使用<code>LinkedBlockingQueue</code>且无参数，即线程队列的大小为<code>Integer.MAX_VALUE</code>，当有任务在执行时，其余任务全都会存放在队列中等待执行。</p>
<h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><strong>newFixedThreadPool</strong></h2><blockquote>
<p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line"> <span class="number">0L</span>,TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>相比于<code>newSingleThreadExecutor</code>，允许传入参数来创建固定大小的线程池，其余无区别，即传入参数为1时相当于<code>newSingleThreadExecutor</code></p>
<h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><strong>newCachedThreadPool</strong></h2><blockquote>
<p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到核心线程为0，但允许最大线程为<code>Integer.MAX_VALUE</code>，且闲置经过60s的线程会被回收，即可以根据任务数量来调整线程池的线程数量，使用<code>SynchronousQueue</code>队列，此队列内部没有数据缓存空间，生产者和消费者互相等待，等到对方之后然后再一起离开，也就是说队列中不排队存放任务，每个任务都会交给线程池进行处理。</p>
<h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a><strong>newScheduledThreadPool</strong></h2><blockquote>
<p>具有定时定期执行任务功能的线程池。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">            DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心线程固定，最大线程无穷大，但非核心线程闲置后会被立即回收，可以通过<code>schedule()</code>等方法启动，进行延迟操作。</p>
<h1 id="无法处理线程时的Handler"><a href="#无法处理线程时的Handler" class="headerlink" title="无法处理线程时的Handler"></a>无法处理线程时的Handler</h1><blockquote>
<p>RejectedExecutionHandler接口提供了对于拒绝任务的处理的自定方法的机会。在ThreadPoolExecutor中已经默认包含了4中策略。</p>
</blockquote>
<ul>
<li><p>CallerRunsPolicy（直接运行run方法）：线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</p>
</li>
<li><p>AbortPolicy（抛异常）：处理程序遭到拒绝将抛出运行时RejectedExecutionException。</p>
</li>
<li><p>DiscardPolicy（直接丢弃）：不能执行的任务将被删除。</p>
</li>
<li><p>DiscardOldestPolicy（抛弃最老的线程）：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序链表</title>
    <url>/2019/12/06/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="Leetcode21-合并两个有序链表"><a href="#Leetcode21-合并两个有序链表" class="headerlink" title="Leetcode21.合并两个有序链表"></a>Leetcode21.合并两个有序链表</h1><p><strong>题目描述：</strong></p>
<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例：</strong></p>
<pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><p><strong>思路：</strong></p>
<p>第一种思路就像合并两个有序数组一样，不断的判断大小放进新数组就好了，这种就是要考虑当其中一个为空的情况，直接把另一个加入到新的里。</p>
<p>第二种就是递归，将一个节点加入新链表后，又变成了合并两个有序链表的问题，两种思路流程差不多。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode cur = pre;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &gt; l2.val)&#123;</span><br><span class="line">            val = l2.val;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            val = l1.val;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) cur.next = l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) cur.next = l1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pre.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种思路第一点要注意一个链表已经遍历完成后的处理，第二点是对于新链表需要两个引用，一个指向头，一个指向当前要加入的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归的代码就比较简洁。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2019/12/06/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="Leetcode206-反转链表"><a href="#Leetcode206-反转链表" class="headerlink" title="Leetcode206.反转链表"></a>Leetcode206.反转链表</h1><p><strong>题目描述：</strong></p>
<p>反转一个单链表。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p><strong>思路：</strong></p>
<p>反转链表也是一个比较有代表性的链表操作，因为链表的特性，所以很多链表题都可以通过递归来完成，反转链表可以通过递归和迭代来完成。</p>
<p>对于递归操作，反转当前节点后的链表，然后要把当前节点加到链表尾部去，也就是说我们要有尾部节点的引用，恰好反转后尾部节点就是反转前当前节点的下一节点，也就是当前节点的next</p>
<p>对于迭代操作，我们需要把当前节点的next指向上一节点即可，这里要注意的就是，如果直接把当前节点指向上一节点，我们就会丢失之后的链表引用，所以要提前保存之后的节点。</p>
<p><strong>代码：</strong></p>
<p>递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.next;<span class="comment">//先保存之后的链表部分</span></span><br><span class="line">        cur.next = pre;<span class="comment">//反转当前节点</span></span><br><span class="line">        pre = cur;<span class="comment">//当前节点成为上一节点</span></span><br><span class="line">        cur = next;<span class="comment">//下一节点成为当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代这里可以不用声明那么多节点，但是为了清晰还是多声明点，迭代相比递归，更考验对链表操作的熟悉程度。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>相交链表</title>
    <url>/2019/12/06/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="Leetcode160-相交链表"><a href="#Leetcode160-相交链表" class="headerlink" title="Leetcode160.相交链表"></a>Leetcode160.相交链表</h1><p><strong>题目描述：</strong></p>
<p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p><strong>示例：</strong></p>
<pre><code>A:          a1 → a2
                    ↘
                    c1 → c2 → c3
                    ↗
B:    b1 → b2 → b3</code></pre><p>例如对于A，B链表，返回c1节点</p>
<p><strong>思路：</strong></p>
<p>看到这个题最直接的想法就是遍历，但仔细想想遍历的话我们需要遍历A中每一个节点，然后判断它是否和B中一个节点相同，时间复杂度O(mn)，显然不是好算法，第二种想法可以遍历A中节点，并存在哈希表中，这样同样是遍历，但是哈希表查找的时间复杂度O(1)，可以让算法时间复杂度成为O(m+n)，自己觉得这个方法已经比较好了，因为是线性时间，但是还是有更好的方法，线性时间且空间复杂度为O(1)。</p>
<p>我们设A链表长度为a + c，B链表长度为b + c，A和B的遍历长度不定，但A+B的遍历长度是一样的，我们用两个指针，一个按AB顺序遍历，一个按BA顺序遍历，也就是a + c + b + c，另一个b + c + a + c，从这里可以看出，当两个指针都走a + b + c时，它们可以同时到达相交节点，这个节点就是结果。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(headA != <span class="keyword">null</span>)&#123;</span><br><span class="line">        set.add(headA);</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(headB != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(headB)) <span class="keyword">break</span>;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    ListNode l1 = headA;</span><br><span class="line">    ListNode l2 = headB;</span><br><span class="line">    <span class="keyword">while</span>(l1 != l2)&#123;</span><br><span class="line">        l1 = (l1 == <span class="keyword">null</span>) ? headB : l1.next;</span><br><span class="line">        l2 = (l2 == <span class="keyword">null</span>) ? headA : l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于最后这种遍历方式，记得之前做链表中环找环节点的时候也遇到过，遇到链表找节点的题可以多思考思考不同的遍历方式，尤其很多时候需要两个指针。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet源码阅读</title>
    <url>/2019/12/06/HashSet%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<pre><code>HashSet也是Set集合中用的比较多的，所以也读一读源码。</code></pre><h1 id="HashSet的特点"><a href="#HashSet的特点" class="headerlink" title="HashSet的特点"></a>HashSet的特点</h1><ul>
<li>存入元素不能重复</li>
<li>存入元素无序</li>
<li>可以存null</li>
</ul>
<h1 id="核心成员变量"><a href="#核心成员变量" class="headerlink" title="核心成员变量"></a>核心成员变量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashSet底层是基于HashMap存储数据，该map的key就是HashSet要存放的数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="comment">//该变量用来填充上一个map的value字段，因为HashSet关注的是map的Key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p>HashSet的底层是通过HashMap实现的，HashSet存放的实际数据也就是HashMap的key，调用无参构造方法时，会实例化一个HashMap对象。</p>
<h1 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加一个元素，如果该元素已经存在，则返回true，如果不存在，则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//往map中添加元素，返回null，说明是第一个往map中添加该key</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>往hashSet中添加元素，实际是往map成员变量里面添加对应的key和value；</li>
<li>map中的key实际就是要添加的元素，value是一个固定的对象；</li>
<li>当第一次往map中添加key时，添加成功返回null，所以当第一次往hashSet中添加元素时，会返回true；</li>
<li>由于hashMap中的key不能重复，所以hashSet不能存储重复元素。</li>
</ul>
<h1 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除指定的元素，删除成功返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实际是删除map中的一个对象</span></span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当hashSet删除一个元素时，实际是操作map删除对应的元素；</li>
<li>当删除map中一个不存在的对象是，会返回null，所以这里当返回PERSENT时，说明之前hashSet往map中添加过对应的元素，因此，当remove(o)返回true时，说明之前已经存在该元素，并且成功删除；当返回false时，说明之前并没有添加过该对象；</li>
</ul>
<h1 id="Iterator-方法实现"><a href="#Iterator-方法实现" class="headerlink" title="Iterator()方法实现"></a>Iterator()方法实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取hashSet的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用map获取keySet</span></span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashset获取迭代器实际是获取map的keySet的iterator；</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说只要知道HashSet底层是通过HashMap来实现的就好了，HashSet的一些方法基本也是对HashMap实例的操作和方法调用，然后了解HashSet的一些特点，并且因为HashSet不提供get方法，所以获取数据的话可以通过Iterator获取。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>容器集合</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>GROUP BY的用法问题</title>
    <url>/2019/12/05/GROUP-BY%E7%9A%84%E7%94%A8%E6%B3%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<pre><code>在牛客做SQL题遇到了一个问题，这篇博客记录一下，也做个提醒。</code></pre><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary<br>（当前表示的是to_date = ‘9999-01-01’的行数据）</p>
<pre><code>CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`from_date`));</code></pre><h1 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h1><p><img src="https://user-images.githubusercontent.com/45253106/70237603-8747ec80-17a2-11ea-8526-8014435b3323.png" alt="image"></p>
<h1 id="解答与问题"><a href="#解答与问题" class="headerlink" title="解答与问题"></a>解答与问题</h1><p>我第一次写出的答案是这样的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.dept_no,d.emp_no,<span class="keyword">MAX</span>(s.salary) <span class="keyword">AS</span> salary</span><br><span class="line"><span class="keyword">FROM</span> dept_emp <span class="keyword">AS</span> d</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">ON</span> d.emp_no = s.emp_no <span class="keyword">AND</span> d.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">AND</span> s.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> d.dept_no</span><br></pre></td></tr></table></figure>
<p>SELECT了没有GROUP BY的列，显然这样应该不行，但是通过了！</p>
<p>了解了一下牛客好像是SQLite判的，好像允许这样，但即使允许，我也不知道为什么它自动匹配了MAX(s.salary)对应的那个emp_no，好像也是SQLite的特性。</p>
<p>因为自己用Mysql比较多，就去查了一下，Mysql5.7之后的版本也可以SELECT没有GROUP BY的列，但不能像上面那样自动匹配，而低版本不允许SELECT没有GROUP BY的列。</p>
<p>况且这个题就算可以SELECT没有GROUP BY的列，用Mysql按上面的方式写依然是错误的，而且上面的写法也没有考虑万一有几个人都是最高薪水的情况，实际场景中几个人工资一样也很正常。</p>
<p>那么如果我们要用Mysql完成的话，首先确定的是我们可以SELECT出dept_on和对应的最大薪水，将它作为临时表，然后我们再连接一次得到员工编号emp_no，问题又来了，如果我们直接和salaries表进行连接的话，因为salaries中没有部门信息，我们连接会直接选出薪水是那几个值的所有人，但这些人并不一定在对应部门，可能有人是自己部门的非最高薪，但恰好是别的部门的最高薪，所以我们还需要建立一个临时表保存员工是哪个部门并且薪资是多少，好在这个操作和第一个临时表是一样的，只是SELECT的列不同，然后我们得到了如下的Mysql语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> maxs.dept_no,curr.emp_no,curr.salary</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(<span class="keyword">SELECT</span> d.dept_no, <span class="keyword">MAX</span>(s.salary)  salary</span><br><span class="line"><span class="keyword">FROM</span> dept_emp  d</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries  s</span><br><span class="line"><span class="keyword">ON</span> d.emp_no = s.emp_no <span class="keyword">AND</span> d.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">AND</span> s.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> d.dept_no)  maxs</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">(<span class="keyword">SELECT</span> d.dept_no, d.emp_no,s.salary</span><br><span class="line"><span class="keyword">FROM</span> dept_emp  d</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries  s</span><br><span class="line"><span class="keyword">ON</span> d.emp_no = s.emp_no <span class="keyword">AND</span> d.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">AND</span> s.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line">)  curr</span><br><span class="line"><span class="keyword">ON</span> maxs.dept_no = curr.dept_no <span class="keyword">AND</span> maxs.salary = curr.salary</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> maxs.dept_no</span><br></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="https://user-images.githubusercontent.com/45253106/70238789-f8889f00-17a4-11ea-8e08-00d19b5ca80b.png" alt="image"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个题首先让我加深了对GROUP BY的概念，虽然很多数据库允许去SELECT没有被GROUP BY的列，但我们还是应该多加注意尽量避免。</p>
<p>以后业务里也难免会遇到上述的情况，如何更简洁高效的获得正确结果，仍然需要打好基础，并且多思考优化问题。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式-动态代理-AOP</title>
    <url>/2019/12/05/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<pre><code>本篇博客总结一下关于代理模式的内容，认识AOP以后才知道是由动态代理实现的，从什么是代理模式。到静态代理和动态代理，到动态代理实现拦截器。</code></pre><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<h2 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h2><p><img src="https://user-images.githubusercontent.com/45253106/71434814-210b1580-2721-11ea-88f7-2204229c3d7d.png" alt="image"></p>
<a id="more"></a>

<p>代理模式中的角色：</p>
<ul>
<li><strong>抽象主题角色（Subject）</strong>：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。</li>
<li><strong>具体主题角色（RealSubject)</strong>：也称为委托角色或者被代理角色。定义了代理对象所代表的目标对象。</li>
<li><strong>代理主题角色（Proxy)</strong>：也叫委托类、代理类。代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。</li>
</ul>
<h1 id="静态代理和动态代理"><a href="#静态代理和动态代理" class="headerlink" title="静态代理和动态代理"></a>静态代理和动态代理</h1><p>代理模式又分为静态代理和动态代理。静态代理是由程序员创建或特定工具自动生成源代码，在对其编译。在程序员运行之前，代理类.class文件就已经被创建了。动态代理是在程序运行时，通过运用反射机制动态的创建而成。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>1.Subject接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.RealSubject</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RealSubject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.Proxy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subject == <span class="keyword">null</span>)</span><br><span class="line">            subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        System.out.print(<span class="string">"I'm Proxy, I'm invoking..."</span>);</span><br><span class="line">        <span class="keyword">this</span>.subject.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Subject subject = <span class="keyword">new</span> Proxy();</span><br><span class="line">subject.operate();</span><br></pre></td></tr></table></figure>

<p>输出</p>
<blockquote>
<p>I’m Proxy, I’m invoking…RealSubject</p>
</blockquote>
<p>以上就是一个静态代理，目标类和代理类实现同一个接口，代理类调用目标类的方法，可以在前后加上代码，也就是要实现的代理内容。</p>
<h3 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h3><ul>
<li>代码重复，如果目标对象的很多方法都需要代理，则需要在每一个方法上加上代理的代码。</li>
<li>对于每一个目标对象都要创建对应的代理。</li>
<li>如果接口有变动，真实主题和代理类同时都要修改，不利于维护。</li>
</ul>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是指在运行时，动态生成代理类。即，代理类的字节码将在运行时生成并载入当前的ClassLoader。也就是说动态代理是通过Java中的反射机制完成的。</p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>Jdk的动态代理是基于接口的。现在想要为RealSubject这个类创建一个动态代理对象，Jdk主要会做一下工作：</p>
<ul>
<li>获取RealSubject上的所有接口列表</li>
<li>确定要生成的代理类的类名，默认为：com.sun.proxy.$ProxyXXXX；</li>
<li>根据需要实现的接口信息，在代码中动态创建该Proxy类的字节码；</li>
<li>将对应的字节码转换为对于的class对象；</li>
<li>创建InvocationHandler实例handler,用来处理Proxy所有方法的调用；</li>
<li>Proxy的class对象以创建的handler对象为参数，实例化一个proxy对象；</li>
</ul>
<p>1.Subject</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">operate1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">operate2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">operate3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">operate4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">operate5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.RealSubject</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject1</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject-operate1()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject-operate2()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject-operate3()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject-operate4()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate5</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject-operate5()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject2</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject2-operate1()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject2-operate2()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject2-operate3()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject2-operate4()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate5</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubject2-operate5()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.Proxy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newProxyInstance</span><span class="params">(Object realObj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = realObj;</span><br><span class="line">        Class&lt;?&gt; classType = <span class="keyword">this</span>.obj.getClass();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(classType.getClassLoader(), classType.getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"I'm Proxy, I'm invoking..."</span>);</span><br><span class="line">        Object object = method.invoke(obj, args);</span><br><span class="line">        System.out.println(object);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Subject object = <span class="keyword">new</span> RealSubject();</span><br><span class="line">Subject subject = (Subject) <span class="keyword">new</span> ProxyHandler()  </span><br><span class="line">          .newProxyInstance(<span class="keyword">new</span> RealSubject());</span><br><span class="line">Subject subject2 = (Subject) <span class="keyword">new</span> ProxyHandler() </span><br><span class="line">          .newProxyInstance(<span class="keyword">new</span> RealSubject2());</span><br><span class="line">subject.operate2();</span><br><span class="line">subject2.operate4();</span><br></pre></td></tr></table></figure>

<p>输出</p>
<pre><code>I&apos;m Proxy, I&apos;m invoking...RealSubject-operate2()
I&apos;m Proxy, I&apos;m invoking...RealSubject2-operate4()</code></pre><p>考虑一下如果上面这个实例用静态代理来实现，要写两个代理类，每个代理类五个方法，非常麻烦，而且如果接口改成10个方法，不仅实现类要改，代理类也要改，而按照上面动态代理的方法，我们的代理类完全不需要更改。</p>
<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>JDK的动态代理依靠接口实现，但有些类并不实现接口，就无法使用JDK代理，Spring的AOP同时使用JDK和CGLIB动态代理，取决于类是否实现了接口。</p>
<p>CGLIB是针对类来实现的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</p>
<p>CGLIB创建某个类A的动态代理类的模式是：</p>
<ul>
<li>查找A上的所有非final的public类型的方法定义</li>
<li>将这些方法的定义转换成字节码</li>
<li>将组成的字节码转换成相应的代理的class对象</li>
<li>实现MethodInterceptor接口，用来处理对代理类上所有方法的请求（这个接口和Jdk动态代理InvocationHandler的功能和角色是一样的）</li>
</ul>
<p>1.RealSubject</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubjectCglib</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RealSubjectCglib"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.Proxy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCglib</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">//Cglib中的加强器，用来创建动态代理</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置要创建动态代理的类</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        <span class="comment">//设置回调，这里相当于是对于代理类上所有方法的调用，都会调用Callback，而Callback则需要实现intercept()方法进行拦截</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        Object obj = enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"I'm Proxy, I'm invoking..."</span>);</span><br><span class="line">        Object object = proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(object);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProxyCglib proxy = <span class="keyword">new</span> ProxyCglib();</span><br><span class="line">RealSubjectCglib cglib = (RealSubjectCglib)proxy.getInstance(<span class="keyword">new</span> RealSubjectCglib());</span><br><span class="line">cglib.operate();</span><br></pre></td></tr></table></figure>

<p>输出</p>
<blockquote>
<p>I’m Proxy, I’m invoking…RealSubjectCglib</p>
</blockquote>
<h1 id="拦截器的实现"><a href="#拦截器的实现" class="headerlink" title="拦截器的实现"></a>拦截器的实现</h1><p>我们经常说AOP是用动态代理实现的，拦截器其实也是对AOP的一种具体实现。在SpringMVC中，拦截器可以通过继承<code>HandlerInterceptorAdapter</code>实现一个拦截器。</p>
<p>关于拦截器的实现，可以看<a href="https://blog.csdn.net/westos_linux/article/details/79103627" target="_blank" rel="noopener">拦截器与动态代理的实现</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实自己最开始了解的是AOP，那时候还不知道代理模式的概念，只是知道Spring中要做日志的话用AOP，代码按照规则写，但完全不懂原理，后来接触到SpringMVC中的拦截器，觉得也是一种AOP，但也是云里雾里，然后了解了代理模式的概念，学习了静态代理和动态代理，才真正明白了AOP的实现方式和原理。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
        <tag>动态代理</tag>
        <tag>拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title>回文字符串</title>
    <url>/2019/12/04/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="Leetcode5-最长回文子串"><a href="#Leetcode5-最长回文子串" class="headerlink" title="Leetcode5.最长回文子串"></a>Leetcode5.最长回文子串</h1><p><strong>题目描述：</strong></p>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot; 也是一个有效答案。</code></pre><hr>
<pre><code>输入: &quot;cbbd&quot;
输出: &quot;bb&quot;</code></pre><p><strong>思路：</strong></p>
<p>回文字符串属于一类题型，常用的方法就是动态规划和中心扩展，还有著名的马拉车算法可以把时间复杂度降低到线性，这两道题一个用动态规划一个用中心扩展。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; s.length(); j++)&#123;</span><br><span class="line">            dp[i][j] = (s.charAt(i) == s.charAt(j)) &amp;&amp; (j - i &lt; <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; (j - i &gt;= end - start))&#123;</span><br><span class="line">                start = i;</span><br><span class="line">                end = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划重要的就是dp公式，这里dp[i][j]表示字符串从i到j是不是回文串，那么它决定于[i + 1][j - 1]，dp另一点就是初始化，在这里应该是长度为1和2的回文串，这里用条件<code>j - i &lt; 2</code>同时做初始化。</p>
<p>因为我们返回时调用了<code>substring()</code>，所以要先判断字符串长度是否为0，另一种方法我们可以直接返回一个字符串，对这个字符串做初始化，将代码里给start，end赋值的地方用<code>substring()</code>来赋值字符串，这样的话就不需要做最初的判断，但是需要多次调用<code>substring()</code>。</p>
<p>写完以后看了看其他解析，发现这个空间复杂度可以降低到O(n)，这里就不改了，主要是总结字符串，以后总结动态规划再仔细探讨这个问题，动态规划很多时候都可以优化空间，因为很多时候我们只需要一行的内容而不是全部。</p>
<h1 id="Leetcode647-回文子串"><a href="#Leetcode647-回文子串" class="headerlink" title="Leetcode647.回文子串"></a>Leetcode647.回文子串</h1><p><strong>题目描述：</strong></p>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: &quot;abc&quot;
输出: 3
解释: 三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.</code></pre><hr>
<pre><code>输入: &quot;aaa&quot;
输出: 6
说明: 6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</code></pre><p><strong>思路：</strong></p>
<p>和上一个题类似，这个题用中心扩展法来做，对于一个长度为n的字符串应该有2n-1个中心，因为中心可能是某个下标或是两个下标的中间，对应<code>&quot;aba&quot;,&quot;abba&quot;</code>两种情况.</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        centerSpread(s, i, i);</span><br><span class="line">        centerSpread(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">centerSpread</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">        right++;</span><br><span class="line">        left--;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码部分分析</title>
    <url>/2019/12/03/ArrayList%E6%BA%90%E7%A0%81%E9%83%A8%E5%88%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<pre><code>平常做算法题或者编程时常用ArrayList，所以最近也看了看ArrayList的源码，加深理解，并学习一些新内容，以下记录一些在阅读过程中理解的部分内容，像插入删除没什么特别的地方就不多描述了。</code></pre><h1 id="ArrayList的特点"><a href="#ArrayList的特点" class="headerlink" title="ArrayList的特点"></a>ArrayList的特点</h1><blockquote>
<p>在阅读源码之前自己想着写的</p>
</blockquote>
<ul>
<li>动态数组实现的变长集合</li>
<li>允许存放空值</li>
<li>允许存放重复元素</li>
<li>查找复杂度O(1)</li>
<li>插入删除性能较差</li>
<li>非线程安全</li>
</ul>
<a id="more"></a>

<h1 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h1><p>ArrayList的默认容量是10，但并不是会自动创建大小为10的数组，如果我们使用无参构造方法，创建的是空数组，在进行插入操作时，扩容机制会按照默认值重新初始化数组，扩容是1.5倍，但不绝对，至于为什么是1.5我也不是很清楚，应该也是基于时间效率和空间的考量，过小会频繁扩容，执行数组复制，过大可能会浪费很多空间。</p>
<p>下面看一下扩容的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 计算最小容量 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 扩容的入口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 扩容的核心方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// newCapacity = oldCapacity + oldCapacity / 2 = oldCapacity * 1.5</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// 如果最小容量超过 MAX_ARRAY_SIZE，则将数组容量扩容至 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到扩容核心方法grow()中也存在几种情况，最基本的是<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是1.5倍扩容，移位运算比乘除运算要高效，当新容量仍小于最小容量时，会直接将新容量更新为最小容量，例如默认容量是10，首次扩容时旧容量为0，会直接更新为10，如果扩容后超过<code>MAX_ARRAY_SIZE</code>，则最大扩充至<code>Integer.MAX_VALUE</code>，如果扩容使得minCapacity会溢出而小于0触发<code>OutOfMemoryError()</code>。</p>
<h1 id="缩容机制"><a href="#缩容机制" class="headerlink" title="缩容机制"></a>缩容机制</h1><p>ArrayList并没有提供自动缩容机制，因此如果大量插入元素之后又大量删除元素，会出现很多空闲位置且不能释放造成浪费，这时我们可以进行手动触发缩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><p>ArrayList 实现了 RandomAccess 接口（该接口是个标志性接口），表明它具有随机访问的能力。ArrayList 底层基于数组实现，所以它可在常数阶的时间内完成随机访问，效率很高。对 ArrayList 进行遍历时，一般有如下两种方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">    <span class="comment">//use</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为ArrayList的随机访问能力，用第二种方法更快，但实际测试会发现两种方法效率相差较小，一般用foreach即可，代码简洁不易出错，当然如果是LinkedList，效率相差很大，避免使用get()。</p>
<h1 id="遍历时删除"><a href="#遍历时删除" class="headerlink" title="遍历时删除"></a>遍历时删除</h1><p>不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。</p>
<p>原因：foreach的本质其实还是Iterator，遍历时会通过判断size大小判断是否有下一个元素，因此进行插入删除操作会出现问题，需要使用Iterator提供的remove方法。</p>
<h1 id="快速失败机制"><a href="#快速失败机制" class="headerlink" title="快速失败机制"></a>快速失败机制</h1><p>ArrayList 迭代器中的方法都是均具有快速失败的特性，当遇到并发修改的情况时，迭代器会快速失败，以避免程序在将来不确定的时间里出现不确定的行为。</p>
<p>java的集合框架很多都是快速失败机制，并发操作时尽量使用<code>java.util.concurrent</code>包中的类，它们是安全失败的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>容器集合</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的字母异位词</title>
    <url>/2019/12/03/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="Leetcode242-有效的字母异位词"><a href="#Leetcode242-有效的字母异位词" class="headerlink" title="Leetcode242.有效的字母异位词"></a>Leetcode242.有效的字母异位词</h1><p><strong>题目描述：</strong></p>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;
输出: true</code></pre><hr>
<pre><code>输入: s = &quot;rat&quot;, t = &quot;car&quot;
输出: false</code></pre><p><strong>说明：</strong></p>
<p>你可以假设字符串只包含小写字母。</p>
<p><strong>思路：</strong></p>
<p>是否是异位词，即每个字符串中字母出现的次数是否相同，因为只包含小写字母，所以我们用一个大小26的数组来存储出现的次数，如果字符更多可以用更大的数组或采用HashMap键值对存储字符和出现次数。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">        cnts[c - <span class="string">'a'</span>]++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t.toCharArray())&#123;</span><br><span class="line">        cnts[c - <span class="string">'a'</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnt : cnts)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>同构字符串</title>
    <url>/2019/12/03/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="Leetcode205-同构字符串"><a href="#Leetcode205-同构字符串" class="headerlink" title="Leetcode205.同构字符串"></a>Leetcode205.同构字符串</h1><p><strong>题目描述：</strong></p>
<p>给定两个字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: s = &quot;egg&quot;, t = &quot;add&quot;
输出: true</code></pre><hr>
<pre><code>输入: s = &quot;foo&quot;, t = &quot;bar&quot;
输出: false</code></pre><hr>
<pre><code>输入: s = &quot;paper&quot;, t = &quot;title&quot;
输出: true</code></pre><p><strong>思路：</strong></p>
<p>同构是指结构相同，也就是说两个字符串中的字符有着一一映射关系，对于映射关系我们很容易想到用哈希来解决，起初我是用HashMap存储它们的映射关系，有一点感觉不好的地方，例如我们以s的字符为键，当s的字符不在key中时，我们需要判断对应的t的字符是否在value中，这样的话要使用containsValue()，感觉效率不高。</p>
<p>然后我改用两个HashMap分别存储s和t的字符为键，值为它们上一次出现的位置，如果位置相同说明它们同构，然后出了一点问题，在代码里详细说一下。</p>
<p>最后采用的是把HashMap改为数组来保存，因为ASCII码只有256个，数组完全可以完成。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Character, Integer&gt; indexS = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; indexT = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(indexS.get(s.charAt(i)) != indexT.get(t.charAt(i))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        indexS.put(s.charAt(i), i);</span><br><span class="line">        indexT.put(t.charAt(i), i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是上面思路中的第二种方法，然后30个用例过了29个，起初我十分疑惑，测试了一下之后发现了问题，这个代码里有一个判断条件<code>indexS.get(s.charAt(i)) != indexT.get(t.charAt(i))</code>，返回值为Integer, 我们知道==和!=的判断比较的是内存地址，小于128时因为会自动转换为int，所以正常，当值为128时，不会拆箱，所以就出现了两个Integer对象值为128进行!=比较，这个会判断为真，因为它们是不同的对象，在堆中有着不同的存储地址。后续也进行了一些修改通过了，但是使得代码整洁性很差。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] indexS = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span>[] indexT = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(indexS[s.charAt(i)] != indexT[t.charAt(i)]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        indexS[s.charAt(i)] = i + <span class="number">1</span>;</span><br><span class="line">        indexT[t.charAt(i)] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后采用了数组方法完成，这里值得注意的一点就是赋值是i + 1，因为本身数组为0，所以应该用i + 1来保存位置。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转字符串里的单词</title>
    <url>/2019/12/03/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="Leetcode151-翻转字符串中的单词"><a href="#Leetcode151-翻转字符串中的单词" class="headerlink" title="Leetcode151.翻转字符串中的单词"></a>Leetcode151.翻转字符串中的单词</h1><p><strong>题目描述：</strong></p>
<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: &quot;the sky is blue&quot;
输出: &quot;blue is sky the&quot;</code></pre><hr>
<pre><code>输入: &quot;  hello world!  &quot;
输出: &quot;world! hello&quot;
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</code></pre><hr>
<pre><code>输入: &quot;a good   example&quot;
输出: &quot;example good a&quot;
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</code></pre><p><strong>说明：</strong></p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
<p><strong>思路：</strong></p>
<p>看到题有种做词法分析的感觉，但是相对来说简单很多，只需要分析空格，首先想到的是利用split()将字符串切分成单词，然后再让单词循环入栈出栈实现翻转，比较简单，下面利用的方法也差不多是一个道理，只是在分割的同时入栈，稍微快一点，因为做题嘛还是少用split()吧。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//尾部添加一个空格，保证最后一个单词正常存储</span></span><br><span class="line">    s += <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) != <span class="string">' '</span>)&#123;</span><br><span class="line">            temp.append(s.charAt(i));</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                stack.push(temp.toString());</span><br><span class="line">                temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">if</span>(!stack.isEmpty()) res.append(stack.pop());</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        res.append(<span class="string">" "</span>);</span><br><span class="line">        res.append(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>读HashMap源码的一些理解</title>
    <url>/2019/12/02/HashMap%E6%BA%90%E7%A0%81%E7%9A%84%E9%83%A8%E5%88%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<pre><code>也谈不上对HashMap做源码分析，网上的分析也很多，此篇博客记录自己学习HashMap的一些收获。</code></pre><h1 id="HashMap中做hash的方法"><a href="#HashMap中做hash的方法" class="headerlink" title="HashMap中做hash的方法"></a>HashMap中做hash的方法</h1><p>存储位置是<code>hash &amp; [n - 1]</code>，如果直接用HashCode()，高位不产生影响，键值对存放在哪里完全取决于低位，例如n = 16时取决于低四位，碰撞几率大。</p>
<p>因为hashCode()返回值为int32位，通过<code>hash ^ (hash &gt;&gt;&gt; 16)</code>，右移16位做异或，也就是高位为高16位，低位为高低16位进行异或的结果，那么低位就是由高位低位一起决定的，这样可以使散列更均匀，减少碰撞概率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="JDK1-8后加入了红黑树"><a href="#JDK1-8后加入了红黑树" class="headerlink" title="JDK1.8后加入了红黑树"></a>JDK1.8后加入了红黑树</h1><p><strong>原因</strong>：我们知道HashMap的平均查找复杂度是O(1)，当发生哈希碰撞时，会将键值对存在同一个桶下的一个链表里，因此当链表过长时，查找复杂度变为了O(n)，这就产生了性能问题，引入红黑树将复杂度变为O(logn)。</p>
<p><strong>转换条件</strong>：当链表长度 &gt;= <code>TREEIFY_THRESHOLD（8）</code>&amp;<code>tab.length &gt;= MIN_TREEIFY_CAPACITY（64）</code></p>
<p><strong>条件分析</strong>：</p>
<ul>
<li>为什么TREEIFY_THRESHOLD为8呢，根据官方的解释，根据概率某一个桶中元素超过8个的概率非常低，很有道理，毕竟我们不希望HashMap很轻易就进行转换红黑树的操作，那为什么UNTREEIFY_THRESHOLD定义为6呢，经过一些思考和查找，首先是链表它的优势在于插入删除效率高，不然我们全都用红黑树就好了，那么链表在长度为8时平均查找长度为4，长度为6时平均查找长度为3，红黑树在长度为8时平均查找长度为3，长度为6时平均查找长度为2.6，在长度小一点的时候查询效率差一点但影响不大，更应该考虑插入删除操作成本，所以UNTREEIFY_THRESHOLD为6，那为什么不是7，实际上7作为分水岭，如果等于8转换为红黑树，等于7又转换为链表，一些情况下会频繁进行红黑树-链表转换。</li>
<li>为什么第二个条件呢，因为当桶容量较小时，如果出现了长链表的情况，说明碰撞几率很高，此时我们应该进行扩容操作减少碰撞。容量小时，优先扩容可以避免一些列的不必要的树化过程。同时，桶容量较小时，扩容会比较频繁，扩容时需要拆分红黑树并重新映射。所以在桶容量比较小的情况下，将长链表转成红黑树是一件吃力不讨好的事。</li>
</ul>
<h1 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h1><p>HashMap中loadFactor的值为0.75，属于一种时间空间折中的策略。</p>
<p><code>过小</code>：使得碰撞更不容易发生，提高查找效率，但会浪费很多空间，例如我们将loadFactor设为0.5，每次桶占一半就会扩容一倍，当capacity为16时，桶为8发生扩容成32，然后桶为16扩容为64，我们会发现这个浪费的空间也是成倍增长，非常浪费空间。</p>
<p><code>过大</code>：虽然可以节省空间，但是更容易发生碰撞，降低效率，例如将loadFactor设为1，即桶不满就不会扩容，会出现大量链表，影响效率。</p>
<h1 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h1><p>在 HashMap 中，桶数组的长度均是2的幂，阈值大小为桶数组长度与负载因子的乘积。当 HashMap 中的键值对数量超过阈值时，进行扩容。</p>
<p>HashMap 的扩容机制与其他变长集合的套路不太一样，HashMap 按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍（如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去。</p>
<p>那么如何保证key的位置呢，根据HashMap的存储位置和扩容方法，我们可以发现，移动后的位置，要么在原位置，要么是在原位置再移动2次幂的位置。<br><img src="https://user-images.githubusercontent.com/45253106/69959234-9b40e380-1541-11ea-9e9c-9a70472e617e.png" alt></p>
<p><img src="https://user-images.githubusercontent.com/45253106/69959257-a8f66900-1541-11ea-8532-850a2c5f0221.png" alt></p>
<p>通过这两张图我们可以很清楚为什么，因为扩容是二倍，在做hash &amp; [n - 1]运算时刚好多了一位，为0则元素是原位置，为1则移动2次幂，同时也使得有50%几率保存在原位置，50%几率移动，使得扩容后元素比较均匀。</p>
<h1 id="桶数组table声明为transient"><a href="#桶数组table声明为transient" class="headerlink" title="桶数组table声明为transient"></a>桶数组table声明为transient</h1><p>java中声明为transient不会被默认的序列化机制序列化，起初了解到这个机制的时候很疑惑，因为桶数组是HashMap的底层数据结构，不被序列化的话如何传输和还原，后来了解到HashMap实现了两个方法来实现序列化，对键值对进行序列化，然后根据键值对可以重建HashMap数据。</p>
<p>之所以不对table进行序列化，主要是因为：</p>
<ul>
<li>table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间</li>
<li>同一个键值对在不同 JVM 下，所处的桶位置可能是不同的，在不同的 JVM 下反序列化 table 可能会发生错误。HashMap 的<code>get/put/remove</code>等方法第一步就是根据 hash 找到键所在的桶位置，但如果键没有覆写 hashCode 方法，计算 hash 时最终调用 Object 中的 hashCode 方法。但 Object 中的 hashCode 方法是 native 型的，不同的 JVM 下，可能会有不同的实现，产生的 hash 可能也是不一样的。也就是说同一个键在不同平台下可能会产生不同的 hash，此时再对在同一个 table 继续操作，就会出现问题。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>容器集合</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的三种遍历</title>
    <url>/2019/12/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<pre><code>二叉树的遍历是二叉树操作基础，这篇博客写一下自己对于二叉树遍历的非递归操作算法，因为递归操作很简单，所以
面试一般会问非递归的操作方法，重在考察对于三种遍历方式的理解和掌握程度。</code></pre><a id="more"></a>
<h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><blockquote>
<p>根-左-右</p>
</blockquote>
<pre><code>思路：用栈保存节点，访问一个节点后，先后将节点的右子树和左子树入栈，则下一个访问节点就是左子树节点，实际
上也变成了一种子操作，和递归类似，只是递归通过函数调用栈保存，我们手动用栈保存，迭代进行。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode p = stack.pop();</span><br><span class="line">        res.add(p.val);</span><br><span class="line">        <span class="keyword">if</span>(p.right != <span class="keyword">null</span>) stack.push(p.right);</span><br><span class="line">        <span class="keyword">if</span>(p.left != <span class="keyword">null</span>) stack.push(p.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><blockquote>
<p>左-根-右</p>
</blockquote>
<pre><code>思路：同样用栈保存，中序遍历要从左开始，因此循环判断是否有左子树并入栈，直到节点没有左子树，此时可以存储
该节点，并访问右子树，迭代操作。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><blockquote>
<p>左-右-根</p>
</blockquote>
<pre><code>思路：对于后序遍历，与前序遍历比较类似，因为左和右其实是类似的概念，所以对于后序遍历可以看做是前序遍历的
反向遍历，我们通过类似前序遍历的操作对树进行遍历，但是存储时将先存储的数据放在后面，或者在返回之前对
List进行逆序操作。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode cur = stack.pop();</span><br><span class="line">        res.addFirst(cur.val);</span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) stack.push(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) stack.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>思路二：前一种方法虽然看起来比较简单，但实际上是比较巧妙的办法，如果我们要按照后序遍历的概念方法进行操
作，如果有左子树还是循环左子树入栈，不同之处在于，当访问中间节点(根节点)时，如何判断此时是否访问过了它
的右子树，这里我们通过保存上一个遍历的TreeNode来进行判断，如果右子树未访问则先访问右子树，访问过则访
问中间节点。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode temp = stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="keyword">null</span> &amp;&amp; temp.right != last)&#123;</span><br><span class="line">                cur = temp.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(temp.val);</span><br><span class="line">                last = temp;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程基本概念</title>
    <url>/2019/11/18/111/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li>
<li>并发：OS的线程调度机制将时间划分为很多时间片段（时间片），尽可能均匀分配给正在运行的程序，获取CPU时间片的线程或进程得以被执行，其他则等待。通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。</li>
<li>线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果。</li>
<li>同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</li>
</ul>
<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p><img src="/2019/11/18/111/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt><br>各种状态一目了然，值得一提的是”blocked”这个状态：<br>线程在Running的过程中可能会遇到阻塞(Blocked)情况</p>
<ul>
<li>调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。</li>
<li>调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）</li>
<li>对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。</li>
<li>此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>用wait()/notify()实现生产者消费者问题</title>
    <url>/2019/11/18/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    <content><![CDATA[<p>转载自：<a href="https://limengting.site/2018/09/24/%E7%94%A8wait()notify()%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">limengting.site</a></p>
<p>这3个方法的作用：</p>
<p><code>wait</code>：线程自动释放其占有的对象锁，并等待notify</p>
<p><code>notify</code>：唤醒一个正在wait当前对象锁的线程，并让它拿到对象锁</p>
<p><code>notifyAll</code>：唤醒所有正在wait前对象锁的线程</p>
<a id="more"></a>

<p>notify和notifyAll的最主要的区别是：notify只是唤醒一个正在wait当前对象锁的线程，而notifyAll唤醒所有。值得注意的是：notify是本地方法，具体唤醒哪一个线程由虚拟机控制；notifyAll后并不是所有的线程都能马上往下执行，它们只是跳出了wait状态，接下来它们还会是竞争对象锁。</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>永远在synchronized的函数或对象里使用wait、notify和notifyAll，不然Java虚拟机会生成 IllegalMonitorStateException。</p>
</li>
<li><p>永远在while循环里而不是if语句下使用wait。这样，循环会在线程睡眠前后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知。</p>
</li>
<li><p>永远在多线程间共享的对象（在生产者消费者模型里即缓冲区队列）上使用wait。</p>
</li>
<li><p>notify 仅仅通知一个线程，并且我们不知道哪个线程会收到通知，然而 notifyAll 会通知所有等待中的线程。换言之，如果只有一个线程在等待一个信号灯，notify和notifyAll都会通知到这个线程。但如果多个线程在等待这个信号灯，那么notify只会通知到其中一个，而其它线程并不会收到任何通知，而notifyAll会唤醒所有等待中的线程。所以更倾向用 notifyAll()，而不是 notify()。</p>
</li>
<li><p>调用wait()/notify()都是在synchronized代码块中，已经拿到对象锁。A线程调用wait()之后A线程释放锁，A线程进入等待状态；B线程调用notify()之后唤醒一个正在wait对象锁的线程，只有A在等待就唤醒A，B不会马上释放锁，要到synchronized代码块退出之后才释放锁。</p>
</li>
</ul>
<p>我们有两个线程，分别名为PRODUCER（生产者）和CONSUMER（消费者），他们分别继承了Producer和Consumer类，而Producer和Consumer都继承了Thread类。Producer和Consumer想要实现的代码逻辑都在run()函数内。Main线程开始了生产者和消费者线程，并声明了一个LinkedList作为缓冲区队列（在Java中，LinkedList实现了队列的接口）。生产者在无限循环中持续往LinkedList里插入随机整数直到LinkedList满。我们在while(queue.size == maxSize)循环语句中检查这个条件。请注意到我们在做这个检查条件之前已经在队列对象上使用了synchronized关键词，因而其它线程不能在我们检查条件时改变这个队列。如果队列满了，那么PRODUCER线程会在CONSUMER线程消耗掉队列里的任意一个整数，并用notify来通知PRODUCER线程之前持续等待。在我们的例子中，wait和notify都是使用在同一个共享对象上的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生产者消费者的缓冲区</span></span><br><span class="line">        Queue&lt;Integer&gt; buffer = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">10</span>;</span><br><span class="line">        Thread producer1 = <span class="keyword">new</span> Producer(buffer, maxSize, <span class="string">"producer1"</span>);</span><br><span class="line">        Thread producer2 = <span class="keyword">new</span> Producer(buffer, maxSize, <span class="string">"producer2"</span>);</span><br><span class="line">        Thread consumer1 = <span class="keyword">new</span> Consumer(buffer, <span class="string">"consumer1"</span>);</span><br><span class="line">        Thread consumer2 = <span class="keyword">new</span> Consumer(buffer, <span class="string">"consumer2"</span>);</span><br><span class="line">        producer1.start();</span><br><span class="line">        producer2.start();</span><br><span class="line">        consumer1.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; buffer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Queue&lt;Integer&gt; buffer, <span class="keyword">int</span> maxSize, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一直会尝试去抢buffer的对象锁</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (buffer) &#123;</span><br><span class="line">                <span class="comment">// 进入了synchronized代码区则表明已经抢到了锁</span></span><br><span class="line">                <span class="comment">// 缓冲区为满，放不下</span></span><br><span class="line">                <span class="keyword">while</span> (buffer.size() == maxSize) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"Buffer is full, cannot produce!"</span>);</span><br><span class="line">                    <span class="comment">// 生产者释放锁，等待被notify</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        buffer.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 随便生产一个10以内的数放入缓冲区</span></span><br><span class="line">                <span class="keyword">int</span> tmp = random.nextInt(<span class="number">10</span>);</span><br><span class="line">                buffer.add(tmp);</span><br><span class="line">                System.out.print(<span class="keyword">this</span>.getName() + <span class="string">" produces value : "</span> + tmp + <span class="string">", size of buffer = "</span> + buffer.size() + <span class="string">", buffer = "</span>);</span><br><span class="line">                <span class="keyword">for</span> (Integer i : buffer) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="comment">// 唤醒在wait的线程，准备释放buffer对象锁</span></span><br><span class="line">                buffer.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; buffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Queue&lt;Integer&gt; buffer, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一直尝试去抢buffer的对象锁</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (buffer) &#123;</span><br><span class="line">                <span class="comment">// 进入了synchronized代码区则表明已经抢到了锁</span></span><br><span class="line">                <span class="keyword">while</span> (buffer.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"Buffer is empty, cannot consume!"</span>);</span><br><span class="line">                    <span class="comment">// 消费者线程被阻塞，释放锁</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        buffer.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从末端消费一个</span></span><br><span class="line">                System.out.print(<span class="keyword">this</span>.getName() + <span class="string">" consumes value : "</span> + buffer.remove() + <span class="string">", size of buffer = "</span> + buffer.size() + <span class="string">", buffer = "</span>);</span><br><span class="line">                <span class="keyword">for</span> (Integer i : buffer) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="comment">// notify在wait的被阻塞的线程，准备释放buffer对象锁</span></span><br><span class="line">                buffer.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始做项目-图书管理</title>
    <url>/2019/11/16/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%81%9A%E9%A1%B9%E7%9B%AE-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<pre><code>这篇博客记录一下自己做一个Demo项目的全过程，写博客一方面督促自己，一方面可以让自己更熟悉流程和细节，项目
资料是从Nowcoder上找的，项目的前端文件是直接使用了源项目文件，后端自己写了一遍。</code></pre><a id="more"></a>
<h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><h2 id="工程简介"><a href="#工程简介" class="headerlink" title="工程简介"></a>工程简介</h2><pre><code>项目利用Maven，利用SpringBoot作为项目主体框架（SpringBoot相比整合SSM少了很多配置，可以把精力放在代码
开发和业务逻辑上，其本质还是SSM），项目使用Freemaker、Web、MyBatis、Aspect四个模块。</code></pre><h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><pre><code>项目实现图书管理，主要包含注册、登录、向书库中添加书目、借书、还书等操作，通过MD5加密算法对用户密码进
行加密，通过cookie与ticket进行登录权限验证。</code></pre><h1 id="项目流程"><a href="#项目流程" class="headerlink" title="项目流程"></a>项目流程</h1><h2 id="项目创建方式"><a href="#项目创建方式" class="headerlink" title="项目创建方式"></a>项目创建方式</h2><ul>
<li>在<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> 挑选模块之后下载到本地，用IDE打开</li>
<li>在IDE中创建项目，我使用的是IDEA，选择Spring initializr，挑选模块后完成创建<h2 id="项目文件夹"><a href="#项目文件夹" class="headerlink" title="项目文件夹"></a>项目文件夹</h2></li>
<li>biz 业务逻辑层，用来存放比较复杂的逻辑</li>
<li>configuration 用来放Spring Boot的代码配置</li>
<li>controllers 控制层，控制器都在这里，也可以认为是网页的入口都在这</li>
<li>dao 持久层，跟数据库交互的包，主要是MyBatis在这里编码</li>
<li>interceptor AOP的代码都在这</li>
<li>model 各种数据模型，对数据的描述</li>
<li>service 一般用作对dao层的封装</li>
<li>utils 工具包，一般都是静态方法。</li>
</ul>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> bookmanager</span><br></pre></td></tr></table></figure>
<pre><code>分别创建三张表user、book、ticket，可以先向book表中插入几条数据</code></pre><h2 id="完成图书的CRUD"><a href="#完成图书的CRUD" class="headerlink" title="完成图书的CRUD"></a>完成图书的CRUD</h2><h3 id="创建图书实体类Book-java"><a href="#创建图书实体类Book-java" class="headerlink" title="创建图书实体类Book.java"></a>创建图书实体类Book.java</h3><pre><code>描述图书的基本属性，对应数据库表，写入Getter和Setter方法</code></pre><h3 id="创建图书的DAO层BookDAO-java"><a href="#创建图书的DAO层BookDAO-java" class="headerlink" title="创建图书的DAO层BookDAO.java"></a>创建图书的DAO层BookDAO.java</h3><pre><code>DAO层就是利用具体SQL实现CRUD，也是常说的Mapper，因为项目是Mybatis作为持久层框架的，所以可以选择写相应
Xml完成映射，或直接用注解，本项目采用的是注解方法（个人感觉能用注解的时候都用注解，很清晰）</code></pre><h3 id="创建BookService-java"><a href="#创建BookService-java" class="headerlink" title="创建BookService.java"></a>创建BookService.java</h3><pre><code>这里的Service层就是对Controller层和Model层的解耦，通用的业务逻辑实现应该在Service层中，如果去掉这一层
其实也可以运行，我们直接在Controller层中实现业务逻辑，并直接调用持久层(也就是DAO层)实现数据库操作，也
可以完成相应内容，但代码的耦合度就变得很高。在本项目中主要是对DAO进行封装。</code></pre><h3 id="创建BookController-java"><a href="#创建BookController-java" class="headerlink" title="创建BookController.java"></a>创建BookController.java</h3><pre><code>Controller也就是MVC中的C，这时候的Controller还不完整，只是先出一个运行效果，可以访问主页，代码也只有
下面几行。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/index"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bookList</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        loadAllBooksView(model);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"book/books"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadAllBooksView</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"books"</span>, bookService.getAllBooks());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="看到运行效果"><a href="#看到运行效果" class="headerlink" title="看到运行效果"></a>看到运行效果</h3><pre><code>访问127.0.0.1:8080/index也就是主页的URL</code></pre><p><img src="/2019/11/16/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%81%9A%E9%A1%B9%E7%9B%AE-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%90%E8%A1%8C.png" alt><br>(其实和写了一个HelloWorld没什么太大区别哈哈哈哈，第一个流程也属于先让项目运行起来，熟悉一下流程)</p>
<h2 id="完成User类和Ticket类"><a href="#完成User类和Ticket类" class="headerlink" title="完成User类和Ticket类"></a>完成User类和Ticket类</h2><h3 id="创建User-java和Ticket-java"><a href="#创建User-java和Ticket-java" class="headerlink" title="创建User.java和Ticket.java"></a>创建User.java和Ticket.java</h3><pre><code>写对应实体类</code></pre><h3 id="创建UserDAO-java和TicketDAO-java"><a href="#创建UserDAO-java和TicketDAO-java" class="headerlink" title="创建UserDAO.java和TicketDAO.java"></a>创建UserDAO.java和TicketDAO.java</h3><pre><code>完成DAO层的CRUD</code></pre><h3 id="创建UserService-java和TicketService-java"><a href="#创建UserService-java和TicketService-java" class="headerlink" title="创建UserService.java和TicketService.java"></a>创建UserService.java和TicketService.java</h3><pre><code>根据需求对DAO层进行封装</code></pre><h2 id="完成工具类"><a href="#完成工具类" class="headerlink" title="完成工具类"></a>完成工具类</h2><pre><code>这部分跟着源项目学习了一下，下面贴一下源项目的介绍。</code></pre><p><strong>MD5.java</strong></p>
<p>这个类就是用来加密的。服务器不保存用户的明文密码是一项基本常识，所以我们用MD5来加密。这里也不要专注于MD5的具体实现方法，这不是我们的主要任务，但建议你至少要知道MD5常用在什么地方，并知道这个加密是不可逆的就可以了。</p>
<p><strong>UuidUtils.java</strong></p>
<p>注意到Cookie都是一串无意义的码串，我们用JDK自带的UUID生成器可以非常方便的生成这样一串随机的字符串。</p>
<p><strong>ConcurrentUtils.java</strong></p>
<p>用来保存当前访问者的容器。我们知道，当web程序运行在web服务器中时，都是并发的<br>环境，拿tomcat来说，对于每一个请求tomcat都会从自己维护的线程池中选一个线程去处理这个请求。ThreadLocal这个类提供了一种线程id到一个泛型的绑定，你可以认为它是一个Map，当我们从里面取数据的时候，实际上是将当前的线程id作为map的key，取出之前这个线程存的东西。这里我们将User保存在里面，这样我们就能随时在程序的任何地方拿出User信息了。</p>
<p><strong>CookieUtils.java</strong></p>
<p>用来封装http请求中的Cookie的操作。</p>
<p><strong>TicketUtils.java</strong></p>
<p>提供了一个生产Ticket的方法。</p>
<p><strong>LoginRegisterException.java</strong></p>
<p>封装的Exception类，用来抛出异常信息。</p>
<p><strong>HostHolder.java</strong></p>
<p>HostHolder是一个重要的类，用来包装ConcurrentUtils.java的方法，并交给Spring容器去管理，使得我们可以在任何时候都能找当前的User，只要用户登录了，我们就将User信息设置到HostHolder里面，这样我们就在其他地方可以直接拿出User来用。</p>
<h2 id="完成登录注册逻辑LoginBiz-java"><a href="#完成登录注册逻辑LoginBiz-java" class="headerlink" title="完成登录注册逻辑LoginBiz.java"></a>完成登录注册逻辑LoginBiz.java</h2><pre><code>biz是business的简写，用来保存较为复杂的业务逻辑，其本身也是一个service，一般命名Service的用来对DAO层进行封装，命名Biz表示复杂业务逻辑。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginBiz</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TicketService ticketService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录逻辑，LoginController调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> email</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> T票的Ticket(String)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String email, String password)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        User user = userService.getUser(email);</span><br><span class="line">        <span class="comment">//验证是否可以登录</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LoginRegisterException(<span class="string">"账户不存在，请重新输入或注册账号"</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.equals(MD5.next(password), user.getPassword()))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LoginRegisterException(<span class="string">"密码不正确"</span>);</span><br><span class="line">        <span class="comment">//检查Ticket</span></span><br><span class="line">        Ticket t = ticketService.getTicket(user.getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;</span><br><span class="line">            t = TicketUtils.next(user.getId());</span><br><span class="line">            ticketService.addTicket(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t.getExpiredAt().before(<span class="keyword">new</span> Date()))&#123;</span><br><span class="line">            ticketService.deleteTicket(t.getId());</span><br><span class="line">            t = TicketUtils.next(user.getId());</span><br><span class="line">            ticketService.addTicket(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ConcurrentUtils.setHost(user);</span><br><span class="line">        <span class="keyword">return</span> t.getTicket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登出逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(String t)</span></span>&#123;</span><br><span class="line">        ticketService.deleteTicket(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> LoginRegisterException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(User user)</span> <span class="keyword">throws</span> LoginRegisterException</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(userService.getUser(user.getEmail()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LoginRegisterException(<span class="string">"用户账号已存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        user.setPassword(MD5.next(user.getPassword()));</span><br><span class="line">        userService.addUser(user);</span><br><span class="line"></span><br><span class="line">        Ticket t = TicketUtils.next(user.getId());</span><br><span class="line">        ticketService.addTicket(t);</span><br><span class="line"></span><br><span class="line">        ConcurrentUtils.setHost(user);</span><br><span class="line">        <span class="keyword">return</span> t.getTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完成控制层Controller"><a href="#完成控制层Controller" class="headerlink" title="完成控制层Controller"></a>完成控制层Controller</h2><h3 id="完成HomeController"><a href="#完成HomeController" class="headerlink" title="完成HomeController"></a>完成HomeController</h3><pre><code>这个是我自己新加的，之前index也就是主页也放在了BookController里，个人感觉不是很合适，分离出来以后BookController只注入BookService，降低耦合度。</code></pre><h3 id="完成BookController"><a href="#完成BookController" class="headerlink" title="完成BookController"></a>完成BookController</h3><pre><code>将借书、还书实现，简单调用BOOKService方法即可。</code></pre><h3 id="完成LoginController"><a href="#完成LoginController" class="headerlink" title="完成LoginController"></a>完成LoginController</h3><pre><code>主要调用LoginBiz方法。</code></pre><h2 id="实现拦截器完成登录权限验证"><a href="#实现拦截器完成登录权限验证" class="headerlink" title="实现拦截器完成登录权限验证"></a>实现拦截器完成登录权限验证</h2><pre><code>两个拦截器一个用来注入host信息，另一个用来进行权限验证。</code></pre><h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><pre><code>此项目基本就是拿来熟悉一下一个SpringBoot项目从零到运行，不得不说真的比SSM项目轻松许多，SSM项目要配置web.xml，spring的xml，springMVC的xml。
项目中也有一些bug，例如退出登录后仍显示登录名，在注册时分配的ticket无效，直到登陆重新创建(虽然没太大影响，但是会多出来一个userid为0的ticket)，自己写的时候也改了一下，在完成项目时仍有问题，不过不属于编码问题，从项目设计就有的问题，例如应该有张表来维护用户和书的借还关系，此项目里A用户借走了书1，B用户点击归还书1也会成功归还，因为是通过book表的status列维护的，本来想在代码里增加一些判断来确保只有借走书的人才可以还，但是直接改的话会增加不少耦合性，代码也会看起来很乱，从设计阶段改的话工作量也很小.</code></pre><h1 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h1><pre><code>https://github.com/zealyoung/SpringBoot-BookManager</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>实战小项目</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划-最大M段子段和</title>
    <url>/2019/11/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E5%A4%A7M%E6%AE%B5%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h2><pre><code>给定由n个整数（可能为负）组成的序列a1、a2、a3...,an,以及一个正整数m，要求确定序列的m个不相交子段，使这m个子段的总和最大！
特别注意：
有些题目可能不存在负数答案，给出的序列全是负数，那么不管m是多少，答案是0。此时选择的子段是0个，不足m个，但符合题意。
也可能有些题目要求，必须选够m个子段。区别在dp数组的初始化。前者要求dp初始为0，后者要求第0行为0，其余为负无穷</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><pre><code>与最大子段和类似，对于最大子段和我们常用分治算法和动态规划求解，对于最大M段子段和也类似，利用二维数组dp，dp[ i ][ j ]，表示前 j 项所构成 i 子段的最大和，且必须包含着第j项，即以第j项结尾.
求dp[ i ][ j ]，有两种情况：

1、dp[ i ][ j ] = dp[ i ] [ j-1 ] + a[ j ] ，即把第j项融合到第 j-1 项的子段中，子段数不变

2、dp[ i ][ j ] = dp[ i-1 ] [ t ] + a[ j ]，（i-1&lt;= t &lt; j ）把第 j 项作为单独的一个子段，然后找一下i-1个子段时，最大的和，然后加上a[ j ] </code></pre>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中的注解</title>
    <url>/2019/11/12/Spring%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>@Controller</strong></p>
<pre><code>标识一个该类是Spring MVC controller处理器，用来创建处理http请求的对象.</code></pre><p><strong>@RestController</strong></p>
<pre><code>Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。</code></pre><p><strong>@Service</strong></p>
<pre><code>用于标注业务层组件，就是加入你有一个用注解的方式把这个类注入到spring配置中。</code></pre><p><strong>@Autowired</strong></p>
<pre><code>用来装配bean，都可以写在字段上，或者方法上。默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired(required=false)。</code></pre><p><strong>@RequestMapping</strong></p>
<pre><code>@RequestMapping 注解可以在控制器类的级别和/或其中的方法的级别上使用。@RequestMapping的用法非常多，可以参考&lt;https://blog.csdn.net/weinichendian/article/details/84247036&gt;</code></pre><p><strong>@RequestParam</strong></p>
<pre><code>用于将请求参数区数据映射到功能处理方法的参数上。</code></pre><p><strong>@ModelAttribute</strong></p>
<pre><code>参考&lt;https://blog.csdn.net/abc997995674/article/details/80464023&gt;</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>经典回溯-N皇后问题</title>
    <url>/2019/11/11/%E7%BB%8F%E5%85%B8%E5%9B%9E%E6%BA%AF-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Leetcode51-N皇后问题"><a href="#Leetcode51-N皇后问题" class="headerlink" title="Leetcode51.N皇后问题"></a>Leetcode51.N皇后问题</h1><p><strong>题目描述</strong>：</p>
<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。<br><img src="/2019/11/11/%E7%BB%8F%E5%85%B8%E5%9B%9E%E6%BA%AF-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/8-queens.png" alt></p>
<a id="more"></a>
<p><strong>示例</strong>：</p>
<pre><code>输入: 4
输出: [
[&quot;.Q..&quot;,  // 解法 1
&quot;...Q&quot;,
&quot;Q...&quot;,
&quot;..Q.&quot;],

[&quot;..Q.&quot;,  // 解法 2
&quot;Q...&quot;,
&quot;...Q&quot;,
&quot;.Q..&quot;]
]
解释: 4 皇后问题存在两个不同的解法。</code></pre><p><strong>思路</strong>：</p>
<p>N皇后问题是一道经典的回溯问题，回溯本质上也是一种搜索算法，在搜索过程中进行”剪枝” + “状态重置”，对于本题来说，例如我们将第二个皇后放在某一个位置不满足条件时，就不需要再去排列其他的皇后，而是直接回溯到放置第二个皇后的前一个状态，并尝试下一个位置，判断是回溯算法后就是如何剪枝让搜索更快，对于此题来说，每行一个皇后，根据不能相互攻击的条件，皇后不能出现在同一列，同一对角线(主、副)，我们利用三个哈希表来存储三个条件。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            nums[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; col = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; master = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; slave = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        backtrack(nums, <span class="number">0</span>, n, col, master, slave, s, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> row, <span class="keyword">int</span> n, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    Set&lt;Integer&gt; col,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Set&lt;Integer&gt; master,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Set&lt;Integer&gt; slave,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Stack&lt;Integer&gt; s,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    List&lt;List&lt;String&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            res.add(makelist(s, n));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!col.contains(i) &amp;&amp; !master.contains(row - i) &amp;&amp;   </span><br><span class="line">                                    !slave.contains(row + i))&#123;</span><br><span class="line">                s.push(nums[i]);</span><br><span class="line">                col.add(i);</span><br><span class="line">                master.add(row - i);</span><br><span class="line">                slave.add(row + i);</span><br><span class="line"></span><br><span class="line">                backtrack(nums, row + <span class="number">1</span>, n, col, master, slave, s, res);</span><br><span class="line"></span><br><span class="line">                slave.remove(row + i);</span><br><span class="line">                master.remove(row - i);</span><br><span class="line">                col.remove(i);</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">makelist</span><span class="params">(Stack&lt;Integer&gt; s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Integer num : s)&#123;</span><br><span class="line">            StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt; n; i++)&#123;</span><br><span class="line">                str.append(<span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            str.replace(num, num + <span class="number">1</span>, <span class="string">"Q"</span>);</span><br><span class="line">            ans.add(str.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>回溯法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2019/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="/2019/11/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/code12.jpg" alt></p>
<a id="more"></a>
<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p>思路：共N-1趟排序，从p = 0到N-1的位置，保证从位置0到位置p的元素有序，将下一个元素插入有序序列形成新的有序序列。</p>
<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<p>是否稳定：稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j, tmp;</span><br><span class="line">        tmp = array[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i; j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; array[j - <span class="number">1</span>]; j--)&#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        array[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>思路：选取一个增量序列共k个，进行k趟排序，每次排序根据增量分成子序列，利用插入排序对子序列进行排序，最后一个增量为1，整个序列进行排序。</p>
<p>时间复杂度：O(n^1.3-2)</p>
<p>空间复杂度：O(1)</p>
<p>是否稳定：不稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> gap = array.length; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j, tmp;</span><br><span class="line">            tmp = array[i];</span><br><span class="line">            <span class="keyword">for</span>(j = i; j &gt;= gap &amp;&amp; tmp &lt; array[j - gap]; j -= gap)&#123;</span><br><span class="line">                array[j] = array[j - gap];</span><br><span class="line">            &#125;</span><br><span class="line">            array[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>思路：循环遍历，每次循环通过两两比较确定一个最大或最小值。</p>
<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<p>是否稳定：稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="comment">//当一次循环没有更改元素位置时，说明数组有序，直接退出</span></span><br><span class="line">        <span class="keyword">boolean</span> canBreak = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                canBreak = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(canBreak) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>思路：选取枢纽元，左右同时移动，将小于枢纽元的放在枢纽元前面，大于枢纽元的放在枢纽元后面，进行递归直到完全有序。</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(logn)</p>
<p>是否稳定：不稳定</p>
<p>tips:</p>
<ul>
<li><p>一般选取第一个元素作为枢纽元，更好的做法是采用三数中值分割法。</p>
</li>
<li><p>由于是递归操作，当数组被分割的很小时采用插入排序更快，一般是5-20。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = partition(array, left, right);</span><br><span class="line">        quickSort(array, left, index - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, index + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = array[left];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; array[right] &gt;= pivot) right--;</span><br><span class="line">        array[left] = array[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; array[left] &lt;= pivot) left++;</span><br><span class="line">        array[right] = array[left];</span><br><span class="line">    &#125;</span><br><span class="line">    array[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><p>思路：在未排序序列中查找出最小(大)元素，放入排序序列起始位置，继续在剩下未排序序列中重复查找，直到完全有序。</p>
<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<p>是否稳定：不稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; array.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &lt; array[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != min)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = array[i];</span><br><span class="line">            array[i] = array[min];</span><br><span class="line">            array[min] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>思路：根据堆的性质，每次用O(1)时间从堆顶获取数组最大值，并将其放在数组最末尾，并重新下滤形成一个Max堆，直到完全有序。</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<p>是否稳定：不稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="comment">//BuildMaxHeap</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = array.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        percDown(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DeleteMax</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        swap(array, <span class="number">0</span> ,i);</span><br><span class="line">        percDown(array, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">percDown</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(tmp = array[i]; <span class="number">2</span> * i + <span class="number">1</span> &lt; n; i = child)&#123;</span><br><span class="line">        child = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(child != n - <span class="number">1</span> &amp;&amp; array[child] &lt; array[child + <span class="number">1</span>])&#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[child] &gt; tmp)&#123;</span><br><span class="line">            array[i] = array[child];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = array[m];</span><br><span class="line">    array[m] = array[n];</span><br><span class="line">    array[n] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>思路：归并排序采用分治算法，每次将序列分对半分，分别对两个序列进行排序，将两个有序序列合成一个完全有序序列。</p>
<p>时间复杂度：O(nlogn);</p>
<p>空间复杂度：O(n);</p>
<p>是否稳定：稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    mergeSort(array, tmp, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] tmp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right - left &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(array, tmp, left, mid);</span><br><span class="line">    mergeSort(array, tmp, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(array, tmp, left, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] tmp, <span class="keyword">int</span> leftPos, <span class="keyword">int</span> rightPos, <span class="keyword">int</span> rightEnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftEnd = rightPos - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmpPos = leftPos;</span><br><span class="line">    <span class="keyword">int</span> nums = rightEnd - leftPos + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[leftPos] &lt;= array[rightPos])&#123;</span><br><span class="line">            tmp[tmpPos++] = array[leftPos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[tmpPos++] = array[rightPos++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(leftPos &lt;= leftEnd)&#123;</span><br><span class="line">        tmp[tmpPos++] = array[leftPos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(rightPos &lt;= rightEnd)&#123;</span><br><span class="line">        tmp[tmpPos++] = array[rightPos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++, rightEnd--)&#123;</span><br><span class="line">        array[rightEnd] = tmp[rightEnd];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
</search>
